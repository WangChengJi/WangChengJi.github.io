<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凉人夢</title>
  
  <subtitle>十里八乡有名的俊后生</subtitle>
  <link href="https://wangchengji.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangchengji.github.io/"/>
  <updated>2022-09-06T01:46:51.537Z</updated>
  <id>https://wangchengji.github.io/</id>
  
  <author>
    <name>WangChengJi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://wangchengji.github.io/fwzssd/bae4ff13.html"/>
    <id>https://wangchengji.github.io/fwzssd/bae4ff13.html</id>
    <published>2022-09-01T03:50:06.000Z</published>
    <updated>2022-09-06T01:46:51.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>简介：Redis(REmote DIctionary Server)是用c语言开发的一个开源的高性能键值对(key-value)数据库，Redis 是一个开源（BSD许可）的，<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。是一个NoSQL数据库，NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a><strong>特征：</strong></h4><ul><li><p>高性能。</p><p>内存存储，不走磁盘<code>IO</code>，在大数据量下也可以高性能运行。</p><p>官方提供测试数据，50个并发执行100000个请求,读110000 次&#x2F;s,写81000次&#x2F;s</p></li><li><p>数据结构丰富</p><p>支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及<code>zset</code>(sorted set：有序集合)。</p></li><li><p>原子性</p><p>核心读写部分是单线程的，排队执行，对应的操作便具有了原子性，避免了多线程操作带来的复杂性和不安全因素。Redis6.0开始，网络传输支持多线程。</p></li><li><p>易拓展。</p><p>关系型数据库中记录、表关系复杂，扩容难度高；<code>NoSQL</code>中数据无关系，<code>Redis</code>3.0开始支持集群，扩容简单。</p></li><li><p>高可用。（高并发、高可用、高性能）</p><p><code>Redis</code>3.0开始支持集群，可以多主多从，当某个节点发生异常时，可以由其他对应节点顶替，保持整个集群的高可用。</p></li><li><p>可持久化（异地灾备）</p><p>支持把数据持久化存储到磁盘中，以便下次启动或遇到故障时，从磁盘加载恢复数据。</p></li></ul><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p><strong>支持的数据类型</strong>（值支持的类型如下，键只有<code>String</code>）</p><ul><li><table><thead><tr><th>支持类型</th><th>表示形式</th></tr></thead><tbody><tr><td>字符串类型</td><td><code>string</code>(普通字符串，常用)</td></tr><tr><td>列表类型</td><td><code>list</code>(按照插入顺序排序，可以有重复元素，可做消息队列)</td></tr><tr><td>Hash类型</td><td><code>hash</code>(适合存储对象)</td></tr><tr><td>集合类型</td><td><code>set</code>(无序集合，没有重复元素)</td></tr><tr><td>有序集合类型</td><td><code>zset/sorted_set</code>(集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素)</td></tr></tbody></table></li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><span style="color:blue"><strong>应用场景：</strong></span></h4><ul><li><span style="color:red">缓存</span>。查询频率较高，长久保存，但又不经常变化的数据。</li><li><span style="color:red">即时信息</span>。临时性的，经常变化的数据。</li><li><code>Session</code>共享。解决分布式系统中<code>session</code>共享的问题。</li><li>其他。诸如：时效性信息、消息队列（MQ MessageQueue）等</li></ul><h3 id="安装配置启动："><a href="#安装配置启动：" class="headerlink" title="安装配置启动："></a>安装配置启动：</h3><ul><li><p><strong>windows下安装运行：</strong></p><p> 下载安装：到GitHub上 <a href="https://github.com/ServiceStack/redis-windows">ServiceStack&#x2F;redis-windows：Vagrant redis configuration 和 MS Open Tech redis port of windows 的二进制版本 (github.com)</a> 下载安装包，解压即完成安装；</p><p>运行：解压目录两个文件分别启动服务端（redis-cli.exe）和客户端（redis-cli.exe），双击启动(默认端口(6379)、默认配置启动)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果双击客户端cmd窗口一闪而过，可以尝试在redis-cli.exe所在目录下打开cmd窗口输入</span></span><br><span class="line">redis-server.exe redis.windows.conf </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server.exe --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server.exe redis.conf --port 6380</span><br></pre></td></tr></table></figure><p>客户端连接服务端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接本机上服务端默认端口</span></span><br><span class="line">redis-cli.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -h 192.168.115.130 -p 6380</span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>linx中下载安装运行：</strong></p><p>下载：登录<code>redis.cn</code>（ <a href="http://download.redis.io/releases/">Index of &#x2F;releases&#x2F; (redis.io)</a> ）下载自己需要下载指定版本的安装包；</p><p>安装和启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.准备工作1：安装wget</span></span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.准备工作2：安装gcc编译环境</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.在/usr/loca目录（用户软件安装目录）创建redis文件夹（包括data文件夹、log文件夹）</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.上传/下载redis安装包到centos，下面两个步骤（1.1和1.2）任选其一即可</span></span><br><span class="line"><span class="comment"># 1.1 上传离线安装包，上传redis安装包到centos7</span></span><br><span class="line"><span class="comment"># crt工具 Alt + p 打开sftp窗口，通过put命令上传到登录用户的home目录</span></span><br><span class="line">put redis-linux-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剪切压缩包到安装目录</span></span><br><span class="line"><span class="built_in">mv</span> /root/redis-linux-5.0.5.tar.gz /usr/local/redis/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 在线下载安装包（需要安装好了wget）</span></span><br><span class="line">wget -P /usr/local/redis http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入redis目录</span></span><br><span class="line"><span class="built_in">cd</span>  /usr/local/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解压到当前目录</span></span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进入解压目录，执行编译</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 进入src目录，可以看到服务端和客户端的启动程序</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server</span><br><span class="line">./redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 6.新建数据目录和日志目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 在任意位置位置启动Redis-server</span></span><br><span class="line"><span class="comment"># 打开linux配置path的文件,</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#在文件末尾添加下面两行,其中REDIS_HOME的值是redis安装的根目录</span></span><br><span class="line"><span class="built_in">export</span> REDIS_HOME=/usr/local/redis/redis-5.0.5</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$REDIS_HOME</span>/src:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p> 指定端口&#x2F;配置文件启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认端口启动服务端</span></span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server ../redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接非默认端口的服务端</span></span><br><span class="line">redis-cli -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用密码连接</span></span><br><span class="line">redis-cli -p 6380 -a 123456</span><br><span class="line"><span class="comment"># 或者连接后使用指定的命令认证</span></span><br><span class="line">auth 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体上和Windows一致</span></span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用docker快速部署redis</strong></p><p> 进入dockerHub官网，查询redis镜像<a href="https://hub.docker.com/_/redis%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9C%80%E6%B1%82%E6%8C%89%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E3%80%82">https://hub.docker.com/_/redis，根据自己的需求按官方文档下载镜像和配置容器。</a></p></li><li><p><strong>退出</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(`quit`、`<span class="built_in">exit</span>`、`ctrl + C` 、`Ctrl +D`)任选其一</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p><p> 宿主机连接虚拟机中的<code>redis</code>服务时，需要关闭保护模式或者绑定对应的<code>redis</code>服务所在设备的网卡。</p></li></ul><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><p>通过修改配置文件，可以让Redis服务运行在不同端口上、允许通过不同的网卡连接等。</p><ul><li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li><li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li></ul><h4 id="常见配置如下"><a href="#常见配置如下" class="headerlink" title="常见配置如下"></a>常见配置如下</h4><p><strong>1）设置Redis服务运行的端口</strong></p><p>port 6379</p><p><strong>2）设置Redis服务后台运行</strong></p><p>​将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p><p>​注意：Windows版的Redis不支持后台运行。</p><p><strong>3）</strong>设置<code>Redis</code>服务密码(如果是云主机建议设置密码)</p><p>​将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p><p><strong>4）</strong>设置允许客户端远程连接Redis服务</p><p>​远程连接redis注意防火墙设置</p><p>​Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p><p><strong>解释说明：</strong></p><blockquote><p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p><p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p><p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p><p>requirepass：设置Redis的连接密码</p><p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p></blockquote><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </li><li><strong>EXISTS</strong> key  检查给定 key 是否存在</li><li><strong>TYPE</strong> key  返回 key 所储存的值的类型</li><li><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</li></ul><h4 id="学习站"><a href="#学习站" class="headerlink" title="学习站"></a>学习站</h4><p>更多命令可以参考<a href="https://www.redis.net.cn/tutorial/3516.html">Redis中文网</a>或<a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程</a>。</p><h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jedis操作Redis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 执行具体的操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis.del(&quot;username&quot;);</span></span><br><span class="line"></span><br><span class="line">        jedis.hset(<span class="string">&quot;myhash&quot;</span>,<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hValue</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;addr&quot;</span>);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataredis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springdataredis_demo</span></span><br><span class="line">  <span class="comment">#Redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#操作的是0号数据库</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="comment">#Redis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">4</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><p>第四步：提供配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><p>第五步：提供测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作字符串类型数据"><a href="#操作字符串类型数据" class="headerlink" title="操作字符串类型数据"></a>操作字符串类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作String类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>,<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;city123&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，同时设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="number">10l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，如果存在则不执行任何操作</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;city1234&quot;</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    System.out.println(aBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作哈希类型数据"><a href="#操作哈希类型数据" class="headerlink" title="操作哈希类型数据"></a>操作哈希类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Hash类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有字段</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有值</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作列表类型数据"><a href="#操作列表类型数据" class="headerlink" title="操作列表类型数据"></a>操作列表类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作List类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    List&lt;String&gt; mylist = listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String value : mylist) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得列表长度 llen</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> size.intValue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">        <span class="comment">//出队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作集合类型数据"><a href="#操作集合类型数据" class="headerlink" title="操作集合类型数据"></a>操作集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Set类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作有序集合类型数据"><a href="#操作有序集合类型数据" class="headerlink" title="操作有序集合类型数据"></a>操作有序集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作ZSet类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">11.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">12.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">13.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改分数</span></span><br><span class="line">    zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用操作，针对不同的数据类型都可以操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取Redis中所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个key是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">itcast</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定key</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定key对应的value的数据类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;h3 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://wangchengji.github.io/fwzssd/c24675b4.html"/>
    <id>https://wangchengji.github.io/fwzssd/c24675b4.html</id>
    <published>2022-08-28T09:21:22.000Z</published>
    <updated>2022-08-28T10:23:10.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL相关知识"><a href="#MySQL相关知识" class="headerlink" title="MySQL相关知识"></a>MySQL相关知识</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="七大事务传播行为"><a href="#七大事务传播行为" class="headerlink" title="七大事务传播行为"></a>七大事务传播行为</h5><ol><li><p><strong>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</strong></p></li><li><p><strong>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</strong></p></li><li><p><strong>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</strong></p></li><li><p><strong>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</strong></p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</strong>(新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作；)</p></li><li><p><strong>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</strong></p></li><li><p><strong>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作</strong>。(嵌套事物是子事物套在父事物中执行，子事物是父事物的一部分，在进入子事物之前，父事物建立一个回滚点，叫save point，然后执行子事物，这个子事物的执行也算是父事物的一部分，然后子事物执行结束，父事物继续执行。重点就在于那个save point)</p></li></ol><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li><p><strong>读未提交（read Uncommited）:</strong> </p><p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项 目中基本不怎么用， 安全性太差；</p></li><li><p><strong>读已提交（read commited）:</strong> </p><p>这是大多数数据库默认的隔离级别，但是不是 MySQL 的默认隔离级别；这个隔离级别满足 了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等 问题；</p></li><li><p><strong>可重复读（Repeatable read）：</strong> </p><p> 这是 MySQL 的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取 到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简 单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当 36 用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通 过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题；</p></li><li><p><strong>可串行化（serializable）：</strong></p><p> 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之， 它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一 般为了提升程序的吞吐量不会采用这个；</p></li></ul><h5 id="脏读、不可重复读、可重复读、幻读"><a href="#脏读、不可重复读、可重复读、幻读" class="headerlink" title="脏读、不可重复读、可重复读、幻读"></a>脏读、不可重复读、可重复读、幻读</h5><ul><li><p><strong>dirty reads（脏读）：</strong>就是说事务A未提交的数据被事务B读走，如果事务A失败回滚，将导致B所读取的数据是错误的。</p></li><li><p><strong>non-repeatable reads（不可重复读）：</strong>，就是说事务A中两处读取数据，第一次读时是100，然后事务B把值改成了200，事务A再读一次，结果就发现值变了，造成A事务数据混乱。</p></li><li><p><strong>phantom read（幻读）：</strong>，和不可重复读相似，也是同一个事务中多次读不一致的问题。但是不可重复读的不一致是因为它所要取的数据集被改变了，而幻读所要读的数据不一致却不是他所要读的数据改变，而是它的条件数据集改变。比如：Select id where name&#x3D;”ppgogo*”，第一次读去了6个符合条件的id，第二次读时，由于事务B把第一个贴的名字由”dd”改成了“ppgogo9”，结果取出来7个数据。</p></li><li><p><strong>可重复读：</strong>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据。</p></li></ul><h5 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h5><ol><li><strong>原子性：</strong>即不可分割性，事务要么全部被执行，要么就全部不被执行；</li><li><strong>一致性：</strong>事务的执行使得数据库从一种正确状态转换成另一种正确状态 ；</li><li><strong>隔离性：</strong>在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务；</li><li><strong>持久性：</strong>事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障， 事务的处理结果也会得到保存。</li></ol><h4 id="MySQL解决可重复读和幻读的机制"><a href="#MySQL解决可重复读和幻读的机制" class="headerlink" title="MySQL解决可重复读和幻读的机制"></a>MySQL解决可重复读和幻读的机制</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL相关知识&quot;&gt;&lt;a href=&quot;#MySQL相关知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关知识&quot;&gt;&lt;/a&gt;MySQL相关知识&lt;/h3&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引</title>
    <link href="https://wangchengji.github.io/fwzssd/756c412e.html"/>
    <id>https://wangchengji.github.io/fwzssd/756c412e.html</id>
    <published>2022-08-27T01:15:22.000Z</published>
    <updated>2022-08-27T10:10:24.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL的索引的相关知识总结："><a href="#MySQL的索引的相关知识总结：" class="headerlink" title="MySQL的索引的相关知识总结："></a><strong>MySQL的索引的相关知识总结：</strong></h3><p>索引的概述：索引就是高效获取数据的数据结构</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul><li>优点<ol><li>提高数据检索的效率，降低数据库IO成本；</li><li>提高排序效率，通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li></ol></li><li>缺点：<ol><li>索引列会占用部分磁盘空间；</li><li>索引大大提高了查询的效率，同时降低了更新表的速度，关于对表的insert、update、delete操作，效率降低。</li></ol></li><li>总结：因为大多数表在使用的过程中，查询相关的SQL占到百分之95以上，而相较于CPU和内存来说，磁盘的占用带来的成本基本可用忽略，所以为了提高数据的检索效率而使用索引是非常有必要的。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><ul><li><p>B-tree特点：</p><ol><li><p>当节点中的索引key达到上限时中间的key会分裂出去；                         </p></li><li><p>所有的key都会出现在叶子节点，而所有的数据都存储在这些叶子节点上；</p></li><li><p>叶子节点形成一个单项链表。</p><p><img src="https://pic.imgdb.cn/item/6309dad716f2c2beb18d31d5.png"></p></li></ol></li><li><p>B+tree特点：</p><p>MySQL索引数据结构对经典的B-tree进行了优化。在原B-tree的基础上，增加一个指向相邻叶子节点的链表指针，形成了双向链表，就形成了带有顺序指针的B+tree，提高了区间访问的性能。</p><p><img src="https://pic.imgdb.cn/item/6309daf116f2c2beb18d407d.png"></p></li><li><p>Hash索引（Memory引擎）特点：</p><ol><li>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中，而如果存在hash冲突的键值（两个或者多个键值hash值相同），可以在对应槽位上增加链表来存储键值；</li><li>Hash索引只能用于对等比较（&#x3D;，in），不支持服务查询（between，&gt;,&lt;,…）;    </li><li>无法利用索引完成排序操作；  </li><li>查询效率高，通常情况只需要一次检索就可以了，效率通常要高于B+tree索引。</li></ol></li><li><p>为什么InnoDB存储引擎选择使用B+tree索引结构？</p><ol><li><p>相对于二叉树，B+tree的层级更加少，可以减少磁盘IO的次数，提高搜索效率；</p></li><li><p>相对于B-tree，因为在Mysql中一个节点代表一个分页，一个分页的大小是有限的（16kb），而B-tree中数据和索引存储在一个节点中，这样就会使得存储在一个节点上的key减少，造成树的高度增加，导致检索数据时磁盘IO次数增加，性能降低；</p></li><li><p>相对于Hash索引，B+tree支持的访问匹配和排序操作，叶子节点的双向链表结构便于范围搜索和排序。</p></li></ol></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键索引</td><td align="left">针对于表中主键创建的索引</td><td align="left">默认自动创建，且只能有一个</td><td align="left">primary</td></tr><tr><td align="left">唯一索引</td><td align="left">避免同一个表中某个数据列中存在相同数据</td><td align="left">可以有多个</td><td align="left">unique</td></tr><tr><td align="left">常规索引</td><td align="left">快速定位特定数据</td><td align="left">可以有多个</td><td align="left"></td></tr><tr><td align="left">全文索引</td><td align="left">全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td align="left">可以有多个</td><td align="left">fulltext</td></tr></tbody></table><p><strong>在InnDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</strong></p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（Clustered index）</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只能有一个</td></tr><tr><td>二级索引（Secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p><strong>聚集索引选取规则：</strong></p><ol><li>如果存在主键，主键索引就是聚集索引；</li><li>如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引；</li><li>如果表没有主键，或没有合适的唯一索引，则InnDB会自动生成一个rowid作为隐藏5的聚集索引。</li></ol><p><strong>简单点说</strong>聚集索引通过主键列上的值创建索引，把整行数据存储在索引所在叶子节点的下面，而二级索引就是通过索引列上的数据创建索引，而在叶子节点下存储的是该行数据的主键。</p><p><strong>InnoDB主键索引的B+tree高度为多高呢？？</strong></p><p>假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。则：</p><p>树高度为2：<br>n<em>8+(n+1)<em>6&#x3D;16</em>1024（一个节点指针比key多一个，一个节点大小为16k）n≈1170 1171</em>16&#x3D;18736<br> 树高度为3：                                                                                                                                           1171<em>1171</em>16&#x3D;21939856</p><h4 id="索引相关操作（SQL）"><a href="#索引相关操作（SQL）" class="headerlink" title="索引相关操作（SQL）"></a>索引相关操作（SQL）</h4><ol><li><p>查询索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure></li><li><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] [fulltext] index 索引名字（自己取） <span class="keyword">on</span>  表名（要添加索引的字段名，可以是多个字段，多字段代表创建联合索引）；</span><br></pre></td></tr></table></figure></li><li><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名。</span><br></pre></td></tr></table></figure></li></ol><h4 id="查询需要优化的SQL（运行慢的SQL）"><a href="#查询需要优化的SQL（运行慢的SQL）" class="headerlink" title="查询需要优化的SQL（运行慢的SQL）"></a>查询需要优化的SQL（运行慢的SQL）</h4><ul><li><p>查看当前数据库状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志：开启慢查询日志定位查询效率低的<code>sql</code>：</p><p>慢查询日志记录了所有执行时间超过指定参数（<code>long_query_time</code>,单位：秒，默认10秒）的所有<code>SQL</code>语句日志。<code>MySQL</code>的慢查询日志默认没有开启，需要在<code>MySQL</code>的配置文件（<code>/etc/my.cnf</code>）中做如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢日志查询</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被认定是慢查询，记录到查询日志</span><br><span class="line">log_query_time=2</span><br></pre></td></tr></table></figure><p>配置完成后，重启MySQL服务器测试，</p><p>查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code>。</p></li><li><p>profile详情查询sql执行时间：</p><p>查看数据库是否支持profile：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>开启profile查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>执行想判断的SQL，然后通过下面指令查询SQL的执行时间：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看每一条<span class="keyword">sql</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles；</span><br><span class="line"></span><br><span class="line">#查看指定query id 的<span class="keyword">sql</span>语句各阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">sql</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li><li><p>explain执行计划:</p><p>语法：explain  + select 语句;</p><p>explain中各字段含义：</p><ol><li>id：select查询的序列号，表示查询中执行select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。连表查询中一般两张表的id都相同且按from后表的顺序查询；如果有子查询子查询中的select的id会更大，子查询先执行。</li><li>select_type：表示select的类型，常见的取值有simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select&#x2F;where之后包含了子查询）等。</li><li>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。<ul><li>NULL：业务代码中一般不太可能达到，不查询表的select查询：select ’A’；</li><li>system：一般出现在查询系统表时;</li><li>const：按主键索引查询;</li><li>ref：一般是二级索引查询;</li><li>range：范围匹配查询;</li><li>index：索引全表扫描;</li><li>all：全表扫描.</li></ul></li><li>possible_key：可能应用在这张表上的索引。</li><li>key：实际用到的索引.</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li>rows：MYSQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</li><li>filtered：表示返回结果的行数占读取行数的百分比，这个值越大越好。</li><li>Extra：其他信息。</li></ol><h4 id="索引使用相关规则"><a href="#索引使用相关规则" class="headerlink" title="索引使用相关规则"></a>索引使用相关规则</h4><ol><li><p><strong>最左前缀法则：</strong>使用联合索引查询时，必须遵守最左前缀法则；即where条件在必须包含复合索引中最左边第一个字段的条件，否则索引不生效，按照索引中字段的顺序，如果条件中不存在中间某个字段的条件，则后面字段的索引也不会生效。（注：where条件中只需要包含相关字段添加即可，条件顺序的并不影响索引的使用）联合查询中使用了范围查询（&gt;,&lt;）：范围查询右侧的列索引生效，在业务允许的条件下可以使用&lt;&#x3D;和&gt;&#x3D;索引就又可以使用了。</p></li><li><p><strong>不能在条件上加函数运算，否则索引将失效。</strong></p></li><li><p><strong>字符串不加引号，会引发隐式类型转换，导致索引失效。</strong></p></li><li><p><strong>模糊查询like：%加前面索引失效，%加后面索引还是生效的。%xx(失效)、xx%（生效）。</strong></p></li><li><p><strong>or连接条件：如果or两侧列都有索引则通过两侧索引查询，如果存在一侧没有索引则来一侧存在索引的列索引会失效。</strong></p></li><li><p><strong>数据评估影响（mysql实现）：如果查询的数据占了表中的大头，mysql判断使用全表扫描效率更高，mysql就会放弃使用索引，进行全表扫描。</strong></p></li><li><p><strong>SQL提示：是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</strong></p><ul><li><p>use index（索引名)   </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ignore index（索引名）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 忽略使用该索引，让这次查询不使用该索引。</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>force index（索引名） </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制此次查询使用该索引</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>覆盖索引</strong>：</p></li></ol><ul><li><p>什么是回表查询？</p><p>场景：存在一张表user有3个字段主键id、name、age；列name存在二级索引，当我们使用select * from user where name &#x3D; ‘zs’,此时就存在回表查询。</p><p>解释：上述sql会根据name字段的二级索引进行查询，但是name字段上的二级索引只保存了name上的值和id，而我们使用select * 查询全字段信息，而age字段的信息是无法通过name字段的二级索引查询到的，这时候就需要进行回表查询，通过二级索引查询到的id再通过主键id的聚集索引查询到这条数据的所有信息。</p></li><li><p>覆盖索引避免回表查询：</p><p>可以使用联合索引，把经常需要查的字段信息合并到一个联合索引中，在select 后只添加这些需要查询的字段，即可通过二级索引就获得需要的字段信息，避免回表查询。</p></li></ul><ol start="9"><li><strong>前缀索引</strong>：</li></ol><ul><li><p>应用场景：大文本或者数据列建立索引时只截取文本前指定长度的数据当做索引。</p></li><li><p>索引长度指定规则：</p><p>当字段类型为字符串（varchar，text等）时,有时候需要索引很长的字符串，这样会让索引变得很大，因为节点的大小有限，单个索引变大，单个节点内可以存储的索引数量就会减少，树的高度就会增加，查询时，浪费大量的磁盘IO，影响查询效率。此时可以用字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure></li><li><p>前缀长度选择：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引过多，维护索引结构的代价就会过大，会影响增删改的效率。</li><li>如果索引列不能存储null值，请在创建表的时候使用not null约束它，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有利于查询。</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;a href=&quot;#MySQL的索引的相关知识总结：&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;/a&gt;&lt;strong&gt;MySQL的索引的相关知识总结：&lt;/strong&gt;&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Development Tool</title>
    <link href="https://wangchengji.github.io/fwzssd/60588ca5.html"/>
    <id>https://wangchengji.github.io/fwzssd/60588ca5.html</id>
    <published>2022-08-26T07:21:03.000Z</published>
    <updated>2022-08-27T10:12:56.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发过程中相关工具的下载："><a href="#java开发过程中相关工具的下载：" class="headerlink" title="java开发过程中相关工具的下载："></a>java开发过程中相关工具的下载：</h2><h4 id="JDK的下载和环境配置："><a href="#JDK的下载和环境配置：" class="headerlink" title="JDK的下载和环境配置："></a>JDK的下载和环境配置：</h4><ul><li><p><input disabled="" type="checkbox"> jdk的下载（建议下载1.8和11的版本）：</p><ol><li><p>打开浏览器输入网址 <a href="https://www.oracle.com/index.html%EF%BC%8C%E8%BF%9B%E5%85%A5[Oracle%E5%AE%98%E7%BD%91](https://www.oracle.com/index.html)">https://www.oracle.com/index.html，进入[Oracle官网](https://www.oracle.com/index.html)</a> ，在<code>Producet</code>下找到<code>Java</code>根据自己的操作系统选择对应的版本进行下载；</p></li><li><p>jdk安装：</p><p> 2.1 下载完JDK到本地后，找到该文件，双击运行JDK安装程序 ，进入JDK安装界面，点击下一步； </p><p>2.2 可以直接默认目录，点击下一步。也可以自定义路径，先创建一个文件夹名为Java，再在该文件夹下创建一个文件夹为JDK安装目录，同时创建一个文件夹为JRE安装目录 ；</p><p> 2.3然后回到JDK安装界面，更改安装路径，为上述所创建的JDK路径，点击下一步（<strong>这里由于第一项开发工具中已经自带了 JRE，则第三项的公共 JRE 可以取消独立安装，上述创建的 JRE 文件夹也不需要了</strong>）。无其他需求，取消安装JRE即可；</p><p>2.4等待一会，会进入 JRE 的安装界面，同样的更改路径，为上述所创建的 JRE 路径，更改完之后点击下一步（<strong>在上一步取消公共 JRE 安装的则不会出现下面的界面，直接到 2.5 安装完成</strong>）； </p><p>2.5至此JDK已经安装完毕，点击关闭 ；</p><p>2.6测试是否安装成功：可以进入安装好的jdk中的bin目录下打开cmd窗口运行<code>java -version</code>出现信息即可。</p></li><li><p>windows版本的jdk百度网盘下载：链接: <a href="https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8">https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8</a> 提取码: k8d8 复制这段内容后打开百度网盘手机App，操作更方便哦</p></li></ol></li><li><p><input disabled="" type="checkbox"> jdk运行环境的配置（为了在任何终端都可以使用jdk）：</p><p>1.windows操作系统中找到系统的高级设置；</p></li></ul><p>​       2.找到环境变量</p><p>​       3.点击新增；</p><p>​       4.新增变量<code>JAVA_HOME</code>，变量值是安装的jdk的根目录（包含bin目录的那个目录）；</p><p>​       5.找到变量<code>Path</code>新增变量 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code> ；</p><p>​       6.测试，在任意终端输入<code>javac</code>得到java配置信息即表示配置成功。</p><h4 id="idea下载和破解："><a href="#idea下载和破解：" class="headerlink" title="idea下载和破解："></a>idea下载和破解：</h4><ul><li><p><input disabled="" type="checkbox"> idea的安装包的下载（建议不要下载过新的版本，使用20~21版本即可方便破解）：</p><ol><li><p>打开浏览器输入<a href="https://www.jetbrains.com/%EF%BC%8C%E8%BF%9B%E5%85%A5">https://www.jetbrains.com/，进入</a> <a href="https://www.jetbrains.com/">Jetbrains官网</a>，点击 Developer Tools，再点击 Intellij IDEA ；</p></li><li><p>点击中间的download，进入IDEA下载界面 ；</p></li><li><p>选择左边的Ultimate版本进行下载安装。Ultimate版本为旗舰版，需要付费，包括完整的功能。Community 版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，后续进行激活 ；</p></li></ol></li><li><p><input disabled="" type="checkbox"> ​     idea安装：</p><ol><li><p>下载完后在本地找到该文件，双击运行 idea 安装程序 ；</p></li><li><p>点击 Next ；</p></li><li><p>选择安装路径，Next ；</p></li></ol></li></ul><p>​          4.按需求选择，点击 Next ,版本不同有不同的选择，之前版本可能需要选择电脑的版本；</p><p>​          5.默认，不用改，直接点 Install，安装 ；</p><p>​         6.安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA 。</p><ul><li><p><input disabled="" type="checkbox"> 破解idea：</p><p>破解idea主要有两种破解方式，永久版破解到2099年，参考 <a href="http://www.itmind.net/13082.html">IntelliJ IDEA 2021.3.3破解教程（亲测有效，激活至2099年） (itmind.net)</a> ；刷新试用时间版，参考 <a href="http://www.itmind.net/12400.html">2022年IntelliJ IDEA最新破解教程，无限重置试用期 (亲测有效) (图文教程) (itmind.net)</a> ；刷新试用时间的破解方式比较容易操作。</p><p>（内附2021版本idea下载破解商品链接: <a href="https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA">https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA</a> 提取码: 865s 复制这段内容后打开百度网盘手机App，操作更方便哦）</p></li></ul><h4 id="maven的下载和配置："><a href="#maven的下载和配置：" class="headerlink" title="maven的下载和配置："></a>maven的下载和配置：</h4><p>1.官网 <a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a> 下载压缩包；</p><p>2.放到安装目录直接解压即可；</p><p>3.国内访问中央仓库过慢，在config包的setting.xml中配置阿里云的镜像地址，加速依赖下载；</p><p>在<mirrors>标签中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.环境配置：和jdk一样，在系统的环境变量中配置maven的变量；</p><p>变量名：MAVEN_HOME</p><p>变量值：maven的根目录</p><p>5.在<code>path</code>变量中新增<code>%MAVEN_HOME%\bin</code>变量</p><h4 id="git的下载："><a href="#git的下载：" class="headerlink" title="git的下载："></a>git的下载：</h4><p>1.进入官网 <a href="https://git-scm.com/">吉特 (git-scm.com)</a> 下载安装包；</p><p>2.双击安装包安装，一直点击next,直到出现install,点击install,然后点击finish，安装完成。 </p><p>3.安装完成后，桌面右键出现Git GUI、Git bash选项，说明已安装： </p><h4 id="数据库图形化软件："><a href="#数据库图形化软件：" class="headerlink" title="数据库图形化软件："></a>数据库图形化软件：</h4><p>1.下载破解Navicat： <a href="http://www.itmind.net/13042.html">Navicat Premium 15 破解激活教程,永久有效(亲测可用) (itmind.net)</a> </p><p>或者 <a href="https://www.downkuai.com/soft/150597.html">Navicat 16破解版(附激活秘钥)下载-Navicat premium 16破解版下载 v16.0.4附安装破解教程-当快软件园 (downkuai.com)</a> </p><h4 id="Redis图形化软件："><a href="#Redis图形化软件：" class="headerlink" title="Redis图形化软件："></a>Redis图形化软件：</h4><p>1.RedisDesktopManager安装包链接: <a href="https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law">https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law</a> 提取码: 8s8d 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>2.QuickRedis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;a href=&quot;#java开发过程中相关工具的下载：&quot; class=&quot;headerlink&quot; title=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;/a&gt;java开发过程中相关工具的下载：&lt;/h2&gt;&lt;h4 id=&quot;JDK的下</summary>
      
    
    
    
    
    <category term="Java" scheme="https://wangchengji.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangchengji.github.io/fwzssd/4a17b156.html"/>
    <id>https://wangchengji.github.io/fwzssd/4a17b156.html</id>
    <published>2022-08-25T09:37:53.819Z</published>
    <updated>2022-08-27T10:11:56.740Z</updated>
    
    <content type="html"><![CDATA[<p>快速发布新文章</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到线上"><a href="#发布到线上" class="headerlink" title="发布到线上"></a>发布到线上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速发布新文章&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;新增文章&quot;&gt;&lt;a href=&quot;#新增文章&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://wangchengji.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
