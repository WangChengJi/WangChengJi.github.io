<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凉人夢</title>
  
  <subtitle>十里八乡有名的俊后生</subtitle>
  <link href="https://wangchengji.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangchengji.github.io/"/>
  <updated>2022-10-12T11:19:32.185Z</updated>
  <id>https://wangchengji.github.io/</id>
  
  <author>
    <name>凉人夢</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="https://wangchengji.github.io/fwzssd/62ceeeec.html"/>
    <id>https://wangchengji.github.io/fwzssd/62ceeeec.html</id>
    <published>2022-10-10T08:10:38.000Z</published>
    <updated>2022-10-12T11:19:32.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><p>数据库事务(简称：事务，Transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成[由当前业务逻辑多个不同操作构成]。</p><p>事务拥有以下四个特性，习惯上被称为ACID特性：</p><p><strong>原子性(Atomicity)：</strong>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p><p><strong>一致性(Consistency)：</strong>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到(这层语义也有说应该属于原子性)。</p><p><strong>隔离性(Isolation)：</strong>多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</p><p><strong>持久性(Durability)：</strong>已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</p><h2 id="2-本地事务"><a href="#2-本地事务" class="headerlink" title="2.本地事务"></a>2.本地事务</h2><p>起初，事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。现在最流行的spring框架中事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。</p><p><strong>开启本地事务的方式：</strong></p><p>1.配置类上加上@EnableTransactionManagement开启本地事务，在相关的类和方法上通过注解@Transactional标识。<br> 2.spring  在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。<br> 3.真正的数据库层的事务提交和回滚是通过bin log或者redo log实现的。</p><h2 id="3-分布式事务"><a href="#3-分布式事务" class="headerlink" title="3.分布式事务"></a>3.分布式事务</h2><p>随着微服务的兴起，本地事务已经满足不了微服务间的事务，为了保证不同数据库的数据一致性，又引入了分布式事务去管理微服务中的事务，分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。</p><h3 id="3-1CAP定理"><a href="#3-1CAP定理" class="headerlink" title="3.1CAP定理"></a>3.1CAP定理</h3><p>CAP定理是分布式系统中的重要理论，在一个分布式系统中最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项，不能同时满足这三项。</p><ul><li>C：Consistency（一致性）</li><li>A：Availability（可用性）</li><li>P：Partition tolerance（分区容错性）</li></ul><p><img src="https://pic1.imgdb.cn/item/6344e98516f2c2beb1bfd820.png"></p><p><strong>一致性（Consistency）</strong></p><p>一致性指”all nodes see the same data at the same time”，<strong>即更新操作成功后，所有节点在同一时间的数据完全一致</strong>。对于一致性的理解，可以从客户端和服务端两个不同的视角来分析。</p><ul><li>从客户端来看，一致性主要指的是多并发请求时更新过的数据如何获取的问题？如果更新过的数据需要立刻被后续的请求获取到就是强一致性，如果能容忍后续的请求部分或者全部访问不到则是弱一致性，如果经过一段时间后要求能访问到更新后的数据则是最终一致性。</li><li>从服务端来看，一致性则是数据更新后如何同步到整个分布式系统，以保证数据最终一致性。</li></ul><p><strong>可用性（Availability）</strong></p><p>可用性指”reads and writes always succeed”，即服务一直可用且能够正常响应（不保证返回的是最新写入的数据）。</p><p>对于一个讲究可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应，因此我们在衡量一个系统可用性的时候，都是通过停机时间来计算的。通过描述一个系统的可用性时，比如某某系统可用性可以达到5个9，意思就是说该系统的可用水平是99.999%，即全年停机时间不超过<code>(1-0.99999)*365*24*60 = 5.256min</code>，这是一个极高的要求。</p><p>好的可用性主要是指系统能够很好的为用户提供服务，不出现操作失败或者访问超时等用户体验不好的情况。一个分布式系统设计会涉及很多子系统，例如负载均衡器、Web服务器、应用代码、缓存系统、数据库服务器等，任何一个节点的不稳定都可以会影响整个系统的可用性。</p><p><strong>分区容错性（Partition tolerance）</strong></p><p>分区容错性指”the system continues to operate despite arbitrary message loss or failure  of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><h3 id="3-2CAP权衡"><a href="#3-2CAP权衡" class="headerlink" title="3.2CAP权衡"></a><strong>3.2CAP权衡</strong></h3><p>上面我们说了CAP定理注定我们只能同时满足其中的两项。</p><p><strong>CA舍弃P</strong></p><p>这种情况在分布式系统中是不存在的，在分布式系统下，网络分区是一个基本要求。如果要舍弃P就意味着舍弃分布式系统，那也就没有必要讨论CAP定理了，这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。因此对于一个分布式系统来说，P是一个基本要求，CAP三者中只能在CA两者之间做权衡，并且要想尽办法提升P。</p><p><strong>CP舍弃A</strong></p><p>如果一个分布式系统不要求强的可用性，即允许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。这样的分布式系统一旦发生网络故障或者消息丢失等情况，就要牺牲用户体验，等数据一致后再让用户访问系统。</p><p>设计成CP的系统比较典型的就是分布式数据库，在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase这种分布式存储系统，如ZooKeeper这种分布式协调系统，数据的一致性是最基本的要求。</p><blockquote><p>  ZooKeeper可以保证任何时刻的请求访问都能得到一致的数据结果，同时具备分区容错性，但不能保证每次服务的可用性，在极端情况下可能会丢失一些请求，需要程序重新请求才能获得结果。ZooKeeper是分布式协调服务，职责是保证数据在其管辖的所有服务之间保持同步一致，所以就很好理解为什么ZooKeeper被设计成CP而不是AP特性的了。</p></blockquote><p><strong>AP舍弃C</strong></p><p>保证高可用和分区容错性的同时，需要放弃一致性，为了保证高可用，用户请求时需要马上返回，每个节点只能用本地数据提供服务，这样会导致全局数据的不一致性。确切的说是放弃了数据强一致性，退而求其次保证数据最终一致性。这种舍弃强一致性而保证系统的分区容错性和可用性的场景非常多，比如电商网站的秒杀活动或者12306购票，在高并发情况下可能需要一些排队机制，这就是在可用性和分区容错性方面保证了系统正常服务，然后在数据的一致性方面做了一些让步，会影响一些用户体验，但也不会造成用户流程的严重阻塞，这种机制虽然在瞬间可能存在数据不一致的情况，但过了一段时间还是要保证最终一致性的。</p><blockquote><p> 对于多数大型互联网应用的场景，主机众多，部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障时有发生，要保证服务达到N个9，保障AP舍弃C（退而求其次保证最终一致性）是常见的一种选择。</p></blockquote><p>CAP如何权衡和取舍没有好坏之分，需要根据不同的业务场景进行选择，适合的才是最好的。对于涉及到钱这种不能有任何差错的场景，数据强一致性是必须要保证的。对于其他场景，比较普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。</p><h3 id="3-3BASE理论"><a href="#3-3BASE理论" class="headerlink" title="3.3BASE理论"></a>3.3<strong>BASE理论</strong></h3><p>在分布式系统中，面对CAP权衡时，通常的做法会选择AP舍弃C（舍弃强一致性但保证最终一致性），这其实也是分布式领域的另外一个理论，叫BASE理论。BASE理论是对CAP理论的延伸，核心思想是即时无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但系统可以采用合适的方式达到最终一致性（Eventual Consistency）。</p><blockquote><p> BASE是指基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。</p></blockquote><p><strong>基本可用（Basically Available）</strong></p><p>基本可用是指分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。如电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务，这就是损失部分可用性的体现。</p><p><strong>软状态（Soft State）</strong></p><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同节点间副本同步的延时就是软状态的体现（如MySQL的复制）。</p><p><strong>最终一致性（Eventual Consistency）</strong></p><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p><h2 id="4-分布式事务的实现方案"><a href="#4-分布式事务的实现方案" class="headerlink" title="4.分布式事务的实现方案"></a>4.分布式事务的实现方案</h2><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="4-1两阶段提交-x2F-XA"><a href="#4-1两阶段提交-x2F-XA" class="headerlink" title="4.1两阶段提交&#x2F;XA"></a>4.1两阶段提交&#x2F;XA</h3><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色</p><p><strong>XA一共分为两阶段：</strong></p><p><strong>第一阶段（prepare）：</strong>即所有的参与者RM准备执行事务并锁住需要的资源。参与者ready时，向TM报告已准备就绪。<br><strong>第二阶段 (commit&#x2F;rollback)：</strong>当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。<br>目前主流的数据库基本都支持XA事务，包括mysql、oracle、sqlserver、postgre</p><p>XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p><p>XA事务的<strong>特点</strong>是：</p><ul><li>简单易理解，开发较容易。</li><li>对资源进行了长时间的锁定，并发度低。</li></ul><p><strong>可能存在的问题：</strong></p><ul><li>单点故障：一旦事务管理器出现故障，整个系统不可用。</li><li>数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li>响应时间较长：整个消息链路是串行的，要等待响应结果，不适合高并发的场景。</li><li>不确定性：当事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li></ul><h3 id="4-2-3PC（三阶段提交）"><a href="#4-2-3PC（三阶段提交）" class="headerlink" title="4.2 3PC（三阶段提交）"></a>4.2 3PC（三阶段提交）</h3><p>相对于 2PC，3PC（三阶段提交）增加了 CanCommit 阶段和超时机制。如果一段时间内没有收到协调者的 commit 请求，那么就会自动进行 commit，解决了 2PC 单点故障的问题。但是性能问题和不一致问题仍然没有根本解决。</p><p><strong>第一阶段：CanCommit 阶段</strong></p><p>此阶段所做的事很简单，就是协调者询问事务参与者，是否有能力完成此次事务。如果都返回 yes，则进入第二阶段；有一个返回 no 或等待响应超时，则中断事务，并向所有参与者发送 abort 请求<br><strong>第二阶段：PreCommit 阶段</strong></p><p>此时协调者会向所有的参与者发送 PreCommit 请求，参与者收到后开始执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。参与者执行完事务操作后(此时属于未提交事务的状态)，就会向协调者反馈“Ack”表示已经准备好提交了，并等待协调者的下一步指令。<br><strong>第三阶段：DoCommit 阶段</strong></p><p>在阶段二中如果所有的参与者节点都可以进行 PreCommit 提交，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送 doCommit 请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈 Ack 消息，协调者收到所有参与者的 Ack 消息后完成事务。相反，如果有一个参与者节点未完成 PreCommit 的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送 abort 请求，从而中断事务。</p><h3 id="4-3TCC"><a href="#4-3TCC" class="headerlink" title="4.3TCC"></a>4.3TCC</h3><p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p><p><strong>TCC分为3个阶段</strong></p><p><strong>Try 阶段：</strong>尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</p><p><strong>Confirm 阶段：</strong>确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。</p><p><strong>Cancel 阶段：</strong>取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。</p><p>TCC<strong>特点</strong>如下：</p><ul><li>并发度较高，无长期资源锁定。</li><li>开发量较大，需要提供Try&#x2F;Confirm&#x2F;Cancel接口。</li><li>TCC适用于订单类业务，对中间状态有约束的业务。</li></ul><p>TCC事务的处理流程与2PC两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。 不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。</p><h3 id="4-4最大努力通知"><a href="#4-4最大努力通知" class="headerlink" title="4.4最大努力通知"></a>4.4<strong>最大努力通知</strong></h3><p>最大努力通知的方案实现比较简单，适用于一些最终一致性要求较低的业务。</p><p>执行流程：</p><ul><li>系统 A 本地事务执行完之后，发送个消息到 MQ。</li><li>这里会有个专门消费 MQ 的服务，该服务会消费 MQ 并调用系统 B 的接口。</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃（这里一般有个阈值，重复执行失败多少次就记录日志或者提醒人工处理）。</li></ul><h3 id="4-5-Sagas-事务模型长时间运行的事务"><a href="#4-5-Sagas-事务模型长时间运行的事务" class="headerlink" title="4.5 Sagas 事务模型长时间运行的事务"></a>4.5 Sagas 事务模型长时间运行的事务</h3><p>其核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。Seata 框架中一个分布式事务包含三种角色：</p><p>「Transaction Coordinator (TC)」：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。「Transaction Manager ™」：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。「Resource Manager (RM)」：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</p><p>seata框架<strong>「为每一个RM维护了一张UNDO_LOG表」</strong>，其中保存了每一次本地事务的回滚数据。</p><p><strong>具体流程：</strong></p><ol><li><p>首先 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</p></li><li><p>XID 在微服务调用链路的上下文中传播。</p></li><li><p>RM 开始执行这个分支事务，RM 首先解析这条 SQL 语句，生成对应的 UNDO_LOG 记录。UNDO_LOG 表中记录了分支 ID，全局事务 ID，以及事务执行的 redo 和 undo 数据以供二阶段恢复。</p></li><li><p>RM 在同一个本地事务中执行业务 SQL 和 UNDO_LOG 数据的插入。在提交这个本地事务前，RM 会向 TC 申请关于这条记录的全局锁 。</p></li><li><p>如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向 TC 汇报本地事务执行失败。</p></li><li><p>RM 在事务提交前，申请到了相关记录的全局锁，然后直接提交本地事务，并向 TC 汇报本地事务执行成功 。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。</p></li><li><p>TC 根据所有的分支事务执行结果，向 RM 下发提交或回滚 命令。RM如果 收到 TC 的提交命令 ，首先 立即释放 相关记录的全局 锁 ，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。</p><p>（1）RM如果 收到 TC 的提交命令 ，首先 立即释放 相关记录的全局 锁 ，然后把提交请求放入一个异步任务的队列中，马上返回提交（2）成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。</p><p>RM如果 收到 TC 的回滚命令 ，则会开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，</p><p>①如果不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。</p><p>②如果相同，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。</p></li></ol><h3 id="4-6小结"><a href="#4-6小结" class="headerlink" title="4.6小结"></a>4.6小结</h3><p>分布式事务本身就是一个技术难题，业务中具体使用哪种方案还是需要不同的业务特点自行选择。分布式事务提高了流程的复杂度，带来很多额外的开销工作，代码量上去了，业务复杂了，性能下跌了。所以，真实开发的过程中，能不使用分布式事务就不使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式事务解决方案&quot;&gt;&lt;a href=&quot;#分布式事务解决方案&quot; class=&quot;headerlink&quot; title=&quot;分布式事务解决方案&quot;&gt;&lt;/a&gt;分布式事务解决方案&lt;/h1&gt;&lt;h2 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Seata" scheme="https://wangchengji.github.io/tags/Seata/"/>
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="https://wangchengji.github.io/fwzssd/62e89ee7.html"/>
    <id>https://wangchengji.github.io/fwzssd/62e89ee7.html</id>
    <published>2022-09-30T06:36:28.000Z</published>
    <updated>2022-10-06T12:24:39.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>权限管理功能，是我们为了满足大型系统中复杂组织架构的设计需求，将资源、角色、权限授权统一组合到一个权限分组中，方便开发者进行管理，分配对应员工对应的权限，屏蔽无关人员操作系统的某个功能，防止误操作产生的垃圾数据或数据丢失。 </p><h2 id="1-RBAC模型"><a href="#1-RBAC模型" class="headerlink" title="1.RBAC模型"></a>1.<strong>RBAC</strong>模型</h2><p>RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。我们可以根据自家产品权限的复杂程度，选取适合的权限模型。</p><h2 id="2-常用的权限管理框架"><a href="#2-常用的权限管理框架" class="headerlink" title="2.常用的权限管理框架"></a>2.常用的权限管理框架</h2><h3 id="2-1Shiro-框架"><a href="#2-1Shiro-框架" class="headerlink" title="2.1Shiro 框架"></a>2.1Shiro 框架</h3><p><code>Shiro</code>是一个功能强大且易于使用的Java安全<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。</p><h4 id="2-1-1核心框架"><a href="#2-1-1核心框架" class="headerlink" title="2.1.1核心框架"></a>2.1.1核心框架</h4><p><img src="https://pic1.imgdb.cn/item/633a81d216f2c2beb1a89e37.png"></p><ol><li><strong>Subject：</strong>Subject即主体，外部应用与subject进行交互，subject记录了当前的操作用户，可以将用户的概念理解为当前操作的主体。外部程序通过subject进行认证授权，而subject是通过SecurityManager安全管理器进行认证授权。</li><li><strong>SecurityManager：</strong>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。</li><li><strong>Authenticator：</strong>Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。</li><li><strong>Authorizer：</strong>Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</li><li><strong>Realm：</strong>Realm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息，还有认证授权校验的相关的代码。</li><li><strong>SessionManager：</strong>sessionManager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现<strong>单点登录</strong>。</li><li><strong>SessionDAO：</strong>SessionDAO即会话dao，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。</li><li><strong>CacheManager：</strong>CacheManager即缓存管理，将用户权限数据存储在缓存，这样可以提高性能。</li><li><strong>Cryptography：</strong>Cryptography即密码管理，shiro提供了一套加密&#x2F;解密的组件，方便开发。比如提供常用的散列、加&#x2F;解密等功能。</li></ol><h4 id="2-1-2简单测试"><a href="#2-1-2简单测试" class="headerlink" title="2.1.2简单测试"></a>2.1.2简单测试</h4><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置shiro配置文件shiro.ini</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 约定写法</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># 用户名=密码</span></span><br><span class="line"><span class="attr">jacko</span>=<span class="number">123456</span></span><br><span class="line"><span class="attr">tide</span>=<span class="number">654321</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroAuthenticatorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、创建安全管理器对象</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line">        <span class="comment">// 2、给安全管理器设置realm</span></span><br><span class="line">        securityManager.setRealm(<span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>));</span><br><span class="line">        <span class="comment">// 3、给全局安全工具类SecurityUtils设置安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 4、拿到当前的subject</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 5、创建令牌</span></span><br><span class="line">        <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;jacko&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6、用户认证</span></span><br><span class="line">            <span class="comment">//subject.isAuthenticated()判断是否认证成功，成功返回ture否则返回false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span>+subject.isAuthenticated());</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span>+subject.isAuthenticated());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            <span class="comment">//判断用户名是否错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：用户不存在！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            <span class="comment">//判断密码是否错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：密码不正确！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>认证的几种状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UnknownAccountException：用户名错误</span><br><span class="line">IncorrectCredentialsException：密码错误</span><br><span class="line">DisabledAccountException：账号被禁用</span><br><span class="line">LockedAccountException：账号被锁定</span><br><span class="line">ExcessiveAttemptsException：登录失败次数过多</span><br><span class="line">ExpiredCredentialsException：凭证过期</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-1-3授权"><a href="#2-1-3授权" class="headerlink" title="2.1.3授权"></a>2.1.3授权</h4><p>用户的认证是在<code>SimpleAccountRealm</code>的<code>doGetAuthenticationInfo</code>的方法中完成的，而SimpleAccountRealm继承自<code>AuthorizingRealm</code>，而<code>AuthorizingRealm</code>中有一个抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection var1)</span>;</span><br></pre></td></tr></table></figure><p>SimpleAccountRealm就是复写了AuthorizingRealm中的这个抽象方法实现的用户认证，所以后面我们需要自定义认证的时候我们就可以自定义一个realm继承自AuthorizingRealm来复写doGetAuthorizationInfo，在这个方法里面实现我们自己的认证逻辑，不仅是认证，有意思的是AuthorizingRealm是继承自AuthenticatingRealm，而AuthenticatingRealm中有个抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken var1)</span> <span class="keyword">throws</span> AuthenticationException;</span><br></pre></td></tr></table></figure><p>这个方法是实现用户授权的方法。</p><p>也就是说通过我们自定义realm继承<code>AuthorizingRealm</code>就可以同时复写认证和授权两个方法。</p><h5 id="2-1-3-1基于角色访问控制"><a href="#2-1-3-1基于角色访问控制" class="headerlink" title="2.1.3.1基于角色访问控制"></a>2.1.3.1基于角色访问控制</h5><p><strong>自定义realm</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMD5Realm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 授权操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取身份信息（用户名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据身份信息从数据库中该用户的角色信息装载进入SimpleAuthorizationInfo</span></span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 返回权限信息对象</span></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 认证操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用自定义Realm认证</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 认证操作</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果认证成功，可以进行授权操作</span></span><br><span class="line">    <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 验证Subject是否具有admin角色</span></span><br><span class="line">        <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 具体授权操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;具有 admin 角色&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 验证Subject是否同时具有admin角色和user角色</span></span><br><span class="line">        <span class="keyword">if</span> (subject.hasAllRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 具体授权操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;同时具有 admin 和 user 角色&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 验证Subject是否具有以下角色中的一种或者多种</span></span><br><span class="line">        List&lt;String&gt; roles = Arrays.asList(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span>[] hasRoles = subject.hasRoles(roles);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; roles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasRoles[i]) &#123;</span><br><span class="line">                <span class="comment">// 具体授权操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;具有 &quot;</span> + roles.get(i) + <span class="string">&quot; 角色&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-2基于权限访问控制"><a href="#2-1-3-2基于权限访问控制" class="headerlink" title="2.1.3.2基于权限访问控制"></a>2.1.3.2基于权限访问控制</h5><p><strong>自定义realm</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMD5Realm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 授权操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取身份信息（用户名）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) principals.getPrimaryPrincipal();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据身份信息从数据库中该用户的权限信息装载进入SimpleAuthorizationInfo</span></span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;user:create:001&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;user:update:*&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 返回权限信息对象</span></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 认证操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用自定义Realm认证</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 认证操作</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果认证成功，可以进行授权操作</span></span><br><span class="line">    <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断Subject是否有创建所有user实例的权限</span></span><br><span class="line">        <span class="keyword">if</span> (subject.isPermitted(<span class="string">&quot;user:create:*&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 具体授权操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;具有 user:create:* 权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断Subject同时具有创建所有user实例的权限和修改001号user实例的权限</span></span><br><span class="line">        <span class="keyword">if</span> (subject.isPermittedAll(<span class="string">&quot;user:create:*&quot;</span>, <span class="string">&quot;user:update:001&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 具体授权操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;同时具有 user:create:* 和 user:update:001 权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断Subject是否具有以下权限中的一种或多种</span></span><br><span class="line">        String[] permissions = &#123;<span class="string">&quot;user:create:*&quot;</span>, <span class="string">&quot;user:update:001&quot;</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span>[] hasPermissions = subject.isPermitted(permissions);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; permissions.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasPermissions[i]) &#123;</span><br><span class="line">                <span class="comment">// 具体授权操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;具有 &quot;</span> + permissions[i] + <span class="string">&quot; 权限&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2Spring-Security"><a href="#2-2Spring-Security" class="headerlink" title="2.2Spring Security"></a>2.2Spring Security</h3><p>Spring Security 主要实现了Authentication（认证，解决who are you? ） 和 Access  Control（访问控制，也就是what are you allowed to do？，也称为Authorization）。Spring  Security在架构上将认证与授权分离，并提供了扩展点。它是一个轻量级的安全框架，做为Spring全家桶的亲儿子，它确保基于Spring的应用程序提供身份验证和授权支持。<strong>它与Spring MVC有很好地集成</strong> ，并配备了流行的安全算法实现捆绑在一起。</p><h4 id="2-2-1SpringSecurity入门案例"><a href="#2-2-1SpringSecurity入门案例" class="headerlink" title="2.2.1SpringSecurity入门案例"></a>2.2.1SpringSecurity入门案例</h4><h5 id="2-2-1-1配置SpringSecurity"><a href="#2-2-1-1配置SpringSecurity" class="headerlink" title="2.2.1.1配置SpringSecurity"></a>2.2.1.1配置SpringSecurity</h5><p>​省略用户查询user的mvc实现……</p><ul><li><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.68<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>创建验证失败工具类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建匿名访问无权限处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.write( <span class="string">&quot;未登录，无法访问!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建认证用户无权访问工具类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.write( <span class="string">&quot;权限不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>认证授权工具类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;GrantedAuthority&gt; authorityList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询用户角色</span></span><br><span class="line">        List&lt;Role&gt; roleList = userService.findRoleByUserId(user.getId());</span><br><span class="line">        <span class="keyword">if</span>(roleList!=<span class="literal">null</span> &amp;&amp; roleList.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Role role : roleList) &#123;</span><br><span class="line">                SimpleGrantedAuthority simpleGrantedAuthority=<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role.getKeyword());</span><br><span class="line">                authorityList.add(simpleGrantedAuthority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询权限</span></span><br><span class="line">        List&lt;Permission&gt; permissionList = userService.findUserPermissionByUserId(user.getId());</span><br><span class="line">        <span class="keyword">if</span>(permissionList!=<span class="literal">null</span> &amp;&amp; permissionList.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Permission permission : permissionList) &#123;</span><br><span class="line">                SimpleGrantedAuthority simpleGrantedAuthority=<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permission.getKeyword());</span><br><span class="line">                authorityList.add(simpleGrantedAuthority);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(user.getUsername(),user.getPassword(),authorityList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>构建SpringSecurity的配置工具类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SecurityAuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPointHandler authenticationEntryPoint;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SecurityAccessDeniedHandler accessDeniedHandler;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置密码解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置用户名和密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//禁用iframe框架</span></span><br><span class="line">        http.headers().frameOptions().disable();</span><br><span class="line">        <span class="comment">//关闭csrf防护 跨站请求防护</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                <span class="comment">//表单登录</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                <span class="comment">//登录页面</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                <span class="comment">//登录访问路径，与页面表单提交路径一致</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/checkLogin&quot;</span>)</span><br><span class="line">                <span class="comment">//登录成功后访问路径</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/pages/main.html&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//登录失败操作</span></span><br><span class="line">                .failureHandler(authenticationFailureHandler)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//认证配置</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/index.html&quot;</span>, <span class="string">&quot;/checkLogin&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//配置静态页面可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/plugins/**&quot;</span>, <span class="string">&quot;/loginstyle/**&quot;</span>,<span class="string">&quot;/favicon.ico&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//任何请求</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//都需要身份验证</span></span><br><span class="line">                .authenticated();</span><br><span class="line">        <span class="comment">//配置无权限访问页面</span></span><br><span class="line">        <span class="comment">//http.exceptionHandling().accessDeniedPage(&quot;/uanuth.html&quot;);</span></span><br><span class="line">        http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">        <span class="comment">//配置退出</span></span><br><span class="line">        http.logout()</span><br><span class="line">                <span class="comment">//退出路径</span></span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                <span class="comment">//退出后跳转页面</span></span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-1-2注解实现接口授权"><a href="#2-2-1-2注解实现接口授权" class="headerlink" title="2.2.1.2注解实现接口授权"></a>2.2.1.2注解实现接口授权</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/checkitem&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckitemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> CheckitemService checkitemService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;CHECKITEM_QUERY&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findcheckitems&quot;)</span></span><br><span class="line"><span class="comment">//    @RequestBody 表示请求参数为json格式</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">findcheckitems</span><span class="params">(<span class="meta">@RequestBody</span> QueryPageBean queryPageBean)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkitemService.findCheckItems(queryPageBean);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;CHECKITEM_ADD&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/saveCheckItem&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveCheckItem</span><span class="params">(<span class="meta">@RequestBody</span> Checkitem checkitem)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> checkitemService.saveCheckItem(checkitem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;CHECKITEM_EDIT&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeCheckItem&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">changeCheckItem</span><span class="params">(<span class="meta">@RequestBody</span> Checkitem checkitem)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkitemService.changeCheckItem(checkitem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;CHECKITEM_DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delCheckItem&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delCheckItem</span><span class="params">(<span class="meta">@RequestBody</span> Checkitem checkitem)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkitemService.delCheckItem(checkitem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;CHECKITEM_DELETE&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delCheckItem&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delCheckItem</span><span class="params">(<span class="meta">@RequestBody</span> Checkitem checkitem)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkitemService.delCheckItem(checkitem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;权限管理&quot;&gt;&lt;a href=&quot;#权限管理&quot; class=&quot;headerlink&quot; title=&quot;权限管理&quot;&gt;&lt;/a&gt;权限管理&lt;/h1&gt;&lt;p&gt;权限管理功能，是我们为了满足大型系统中复杂组织架构的设计需求，将资源、角色、权限授权统一组合到一个权限分组中，方便开发者进行</summary>
      
    
    
    
    
    <category term="Spring Security" scheme="https://wangchengji.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>服务限流</title>
    <link href="https://wangchengji.github.io/fwzssd/b172afff.html"/>
    <id>https://wangchengji.github.io/fwzssd/b172afff.html</id>
    <published>2022-09-27T11:37:08.000Z</published>
    <updated>2022-09-28T12:45:17.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h1><p>限流，当我们的系统被频繁的请求的时候，就有可能将系统压垮，所以为了解决这个问题，需要在每一个微服务中做限流操作。</p><h2 id="1-限流的方式"><a href="#1-限流的方式" class="headerlink" title="1.限流的方式"></a>1.限流的方式</h2><p>限流的实现方式，可以通过nginx限流，网关限流。但是他们都是对一个大的服务进行访问限流，如果现在只是要对某一个服务中的接口方法进行限流呢？这里就可以使用Hystrix和Sentinel实现服务限流，也可以使用google提供的guava工具包中的RateLimiter进行实现，其内部是基于令牌桶算法进行限流计算。</p><p>本篇主要介绍guava实现限流以及各种限流算法。</p><h2 id="2-限流算法"><a href="#2-限流算法" class="headerlink" title="2.限流算法"></a>2.限流算法</h2><ul><li>令牌桶限流</li><li>漏桶限流</li><li>计数器算法</li></ul><h3 id="2-1令牌桶算法"><a href="#2-1令牌桶算法" class="headerlink" title="2.1令牌桶算法"></a>2.1令牌桶算法</h3><p>令牌桶算法是比较常见的限流算法之一，大概描述如下：</p><ol><li>所有的请求在处理之前都需要拿到一个可用的令牌才会被处理； </li><li>根据限流大小，设置按照一定的速率往桶里添加令牌；</li><li>桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；</li><li>请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；</li><li>令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流.</li></ol><p><img src="https://pic1.imgdb.cn/item/6332e51416f2c2beb1159725.png"></p><p>这个算法的实现，有很多技术，Guava(读音: 瓜哇)是其中之一，redis客户端也有其实现。</p><h3 id="2-2漏桶算法"><a href="#2-2漏桶算法" class="headerlink" title="2.2漏桶算法"></a>2.2漏桶算法</h3><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:</p><p><img src="https://pic1.imgdb.cn/item/6332e5fe16f2c2beb116856f.png"></p><h3 id="2-3计数器算法"><a href="#2-3计数器算法" class="headerlink" title="2.3计数器算法"></a>2.3计数器算法</h3><p>计数器算法是在一定的时间间隔里，记录请求次数，当请求次数超过该时间限制时，就把计数器清零，然后重新计算。当请求次数超过间隔内的最大次数时，拒绝访问。</p><p>例如：一个接口每分钟允许访问100次。实现方式如下：</p><p>设置一个计数器 count ，接收一个请求就将计数器加一，同时记录当前时间。</p><p>判断当前时间和上次统计时间是否为同一分钟。</p><p>如果是，则判断 count 是否超过阈值，如果超过阈值，则返回限流拒绝。</p><p>如果不是，则吧 count 重置为1，判断是否超过阈值。</p><p>该计数器算法要求每分钟请求的阈值不超过100个</p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h2><h3 id="3-1Guava实现限流"><a href="#3-1Guava实现限流" class="headerlink" title="3.1Guava实现限流"></a>3.1Guava实现限流</h3><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自定义限流注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义切面类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@Scope</span> </span><br><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitAop</span> &#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> HttpServletResponse httpServletResponse; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">20.0</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.aop.aspect.AccessLimit)&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">limit</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;limit()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                obj = proceedingJoinPoint.proceed();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> JSON.toJSONString(<span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">false</span>, StatusCode.ERROR, <span class="string">&quot;fail&quot;</span>));</span><br><span class="line">                outMessage(httpServletResponse, errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">outMessage</span><span class="params">(HttpServletResponse response, String errorMessage)</span> &#123;</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            outputStream = response.getOutputStream();</span><br><span class="line">            outputStream.write(errorMessage.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>在需要限流的接口上加上AccessLimit注解即可实现接口限流，流控可以通过rateLimiter调整令牌数量来实现。</p><h3 id="3-2Redis实现限流"><a href="#3-2Redis实现限流" class="headerlink" title="3.2Redis实现限流"></a>3.2Redis实现限流</h3><p><strong>自定义注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD,ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123; </span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5</span>; <span class="comment">//限制的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">sec</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5</span>;<span class="comment">//限制的时间段（秒）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加限流拦截器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"><span class="comment">//拦截请求完成限流逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//判断接口限流</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">            <span class="keyword">if</span> (!method.isAnnotationPresent(AccessLimit.class)) &#123;</span><br><span class="line"><span class="comment">//没加限流接口直接放行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">AccessLimit</span> <span class="variable">accessLimit</span> <span class="operator">=</span> method.getAnnotation(AccessLimit.class);</span><br><span class="line">            <span class="keyword">if</span> (accessLimit == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//没加限流接口直接放行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取定义的流量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> accessLimit.limit();</span><br><span class="line">            <span class="comment">//获取定义的时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sec</span> <span class="operator">=</span> accessLimit.sec();</span><br><span class="line">            <span class="comment">//设置唯一key</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CommonUtil.getIpAddr(request) + request.getRequestURI();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">maxLimit</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.opsForValue().get(key) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                maxLimit = Integer.valueOf(redisTemplate.opsForValue().get(key).toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该接口还未被访问 设置key</span></span><br><span class="line">            <span class="keyword">if</span> (maxLimit == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                redisTemplate.opsForValue().set(key, <span class="string">&quot;1&quot;</span>, sec, TimeUnit.SECONDS);  <span class="comment">//set时一定要加过期时间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxLimit &lt; limit) &#123;</span><br><span class="line"><span class="comment">//在流控范围内部 设置该时间内请求+1 注意时间sec不能设置过大</span></span><br><span class="line">                redisTemplate.opsForValue().set(key, (maxLimit + <span class="number">1</span>) + <span class="string">&quot;&quot;</span>, sec, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                output(response, <span class="string">&quot;请求太频繁!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回限流消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">(HttpServletResponse response, String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            outputStream = response.getOutputStream();</span><br><span class="line">            outputStream.write(msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置拦截器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; </span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** * 配置拦截器 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line"> </span><br><span class="line"> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AccessLimitInterceptor</span>())</span><br><span class="line">     .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">     .excludePathPatterns(<span class="string">&quot;不需要限流的页面路径&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要限流的接口上添加注解即可，这种方式是通过redis对单个用户实现的限流，如果用户量很大，则要重新设置key的值为对应接口的唯一值，上述的限流方法还存在一个问题：Redis 更新(set) key值 会重置过期时间问题，如果设置了接口限流而不是对单个用户限流，不同用户一直不间断的访问该接口可能会一直重置该接口key的过期时间，而接口的对应的key值在不断增大，可能存在规定时间虽然请求没有达到限流的值，而key的值通过不断的累加和续期，key的值达到了限流条件。</p><p><strong>关于Redis 更新(set) key值 会重置过期时间的问题，redis的官方文档是这么解释的</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The timeout will only be cleared by commands that delete or overwrite the contents of the key, including DEL, SET, GETSET and all the *STORE commands. This means that all the operations that conceptually alter the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with INCR, pushing a new value into a list with LPUSH, or altering the field value of a hash with HSET are all operations that will leave the timeout untouched.</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><p>如果用DEL, SET, GETSET会将key对应存储的值替换成新的，命令也会清除掉超时时间；如果list结构中添加一个数据或者改变hset数据的一个字段是不会清除超时时间的；如果想要通过set去覆盖值那就必须重新设置expire。</p><p>如果想用上述代码实现接口限流就要另外考虑，在对接口请求+1的同时重新设置expire。</p><p><strong>redis+lua限流</strong></p><p>其实redis实现限流的方式很多，比如redis+lua脚本的方式实现，但博主学艺不精，不太会lua，可以参考其他文章：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/u011296165/article/details/107761489</span><br></pre></td></tr></table></figure><p>站在巨人的肩膀上看世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务限流&quot;&gt;&lt;a href=&quot;#服务限流&quot; class=&quot;headerlink&quot; title=&quot;服务限流&quot;&gt;&lt;/a&gt;服务限流&lt;/h1&gt;&lt;p&gt;限流，当我们的系统被频繁的请求的时候，就有可能将系统压垮，所以为了解决这个问题，需要在每一个微服务中做限流操作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Guava" scheme="https://wangchengji.github.io/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>Java定时任务</title>
    <link href="https://wangchengji.github.io/fwzssd/6926f8db.html"/>
    <id>https://wangchengji.github.io/fwzssd/6926f8db.html</id>
    <published>2022-09-27T04:18:27.000Z</published>
    <updated>2022-09-27T09:54:50.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java定时任务"><a href="#Java定时任务" class="headerlink" title="Java定时任务"></a>Java定时任务</h1><p>在大多数项目中，定时任务都是不可或缺的，定时发放优惠券、定时刷新数据、定时发送邮件等等；在Java中，实现定时任务的方式有很多，最简单的在线程中通过<strong>Thread.sleep</strong>睡眠线程，或者是用<strong>JDK</strong>自带<strong>Timer</strong>实现，或者采用<strong>SpringBoot</strong>中的**@Schedule注解<strong>，又或者采用定时线程池</strong>ScheduledExecutorService**来实现。</p><p>下面简单介绍一下几种实现方式。</p><h2 id="1-线程等待实现"><a href="#1-线程等待实现" class="headerlink" title="1.线程等待实现"></a>1.线程等待实现</h2><p>这种实现原理很简单。就是先创建一个thread，然后让它在while循环里一直运行着，通过sleep方法来达到隔一段时间执行一次任务的效果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//间隔时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Hello !!&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(timeInterval);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到如果定时执行的定时任务可能会占一定的时间，可以让定时线程定时调用线程池中的线程去异步执行要执行的定时任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolTaskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>().threadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//间隔时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//定义定时任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始执行定时任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;定时任务执行完成&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//定义定时线程任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    threadPoolTaskExecutor.submit(runnable1);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(timeInterval);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable2);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">threadPoolTaskExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//设置核心线程数</span></span><br><span class="line">        <span class="comment">//（根据业务情况设置 IO密集型会使内存占有过多 CPU密集型会导致CPU飙高 一般CPU密集型 核心线程数是CPU的核心数）</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//设置最大线程数(一般是核心线程的2倍)</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置线程最大空闲时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//设置缓存队列大小</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//设置拒绝策略 CallerRunsPolicy() 线程没有处理能力时任务会给主线程执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式简单直接，但是能够实现的功能有限，而且需要自己来实现。</p><h2 id="2-JDK自带Timer实现"><a href="#2-JDK自带Timer实现" class="headerlink" title="2.JDK自带Timer实现"></a>2.JDK自带Timer实现</h2><p>目前来看，JDK自带的Timer API算是最古老的定时任务实现方式了。Timer是一种定时器工具，用来在一个后台线程计划执行指定任务。它可以安排任务“执行一次”或者定期“执行多次”。</p><p>在实际的开发当中，经常需要一些周期性的操作，比如每5分钟执行某一操作等。对于这样的操作最方便、高效的实现方式就是使用java.util.Timer工具类。</p><h3 id="2-1Timer类的核心方法如下："><a href="#2-1Timer类的核心方法如下：" class="headerlink" title="2.1Timer类的核心方法如下："></a><strong>2.1Timer类的核心方法如下：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定延迟时间后执行指定的任务</span></span><br><span class="line">schedule(TimerTask task,<span class="type">long</span> delay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定时间执行指定的任务。（只执行一次）</span></span><br><span class="line">schedule(TimerTask task, Date time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟指定时间（delay）之后，开始以指定的间隔（period）重复执行指定的任务</span></span><br><span class="line">schedule(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的时间开始按照指定的间隔（period）重复执行指定的任务</span></span><br><span class="line">schedule(TimerTask task, Date firstTime , <span class="type">long</span> period);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的时间开始进行重复的固定速率执行任务</span></span><br><span class="line">scheduleAtFixedRate(TimerTask task,Date firstTime,<span class="type">long</span> period);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的延迟后开始进行重复的固定速率执行任务</span></span><br><span class="line">scheduleAtFixedRate(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止此计时器，丢弃所有当前已安排的任务。</span></span><br><span class="line">cancal()；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从此计时器的任务队列中移除所有已取消的任务。</span></span><br><span class="line">purge()；</span><br></pre></td></tr></table></figure><h3 id="2-2使用示例"><a href="#2-2使用示例" class="headerlink" title="2.2使用示例"></a><strong>2.2使用示例</strong></h3><p>下面用几个示例演示一下核心方法的使用。首先定义一个通用的<strong>TimerTask</strong>类，用于定义用执行的任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoSomethingTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoSomethingTimerTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//定义任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; : 任务「&quot;</span> + taskName + <span class="string">&quot;」被执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1指定延迟执行一次"><a href="#2-2-1指定延迟执行一次" class="headerlink" title="2.2.1指定延迟执行一次"></a><strong>2.2.1指定延迟执行一次</strong></h4><p>在指定延迟时间后执行一次，这类是比较常见的场景，比如：当系统初始化某个组件之后，延迟几秒中，然后进行定时任务的执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayOneDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">DoSomethingTimerTask</span>(<span class="string">&quot;DelayOneDemo&quot;</span>),<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，延迟一秒之后执行定时任务，并打印结果。其中第二个参数单位为毫秒。</p><h4 id="2-2-2固定间隔执行"><a href="#2-2-2固定间隔执行" class="headerlink" title="2.2.2固定间隔执行"></a><strong>2.2.2固定间隔执行</strong></h4><p>在指定的延迟时间开始执行定时任务，定时任务按照固定的间隔进行执行。比如：延迟2秒执行，固定执行间隔为1秒。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//schedule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">DoSomethingTimerTask</span>(<span class="string">&quot;PeriodDemo&quot;</span>),<span class="number">2000L</span>,<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//scheduleAtFixedRate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedRateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">DoSomethingTimerTask</span>(<span class="string">&quot;FixedRateDemo&quot;</span>),<span class="number">2000L</span>,<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序，会发现2秒之后开始每隔1秒执行一次。</p><p>schedule和scheduleAtFixedRate都可以完成固定间隔执行，但是他们的侧重点不同：</p><p>schedule方法侧重保持<strong>间隔时间</strong>的稳定，而scheduleAtFixedRate方法更加侧重于保持<strong>执行频率</strong>的稳定。</p><h4 id="2-2-3schedule侧重保持间隔时间的稳定"><a href="#2-2-3schedule侧重保持间隔时间的稳定" class="headerlink" title="2.2.3schedule侧重保持间隔时间的稳定"></a><strong>2.2.3schedule侧重保持间隔时间的稳定</strong></h4><p>schedule方法会因为前一个任务的延迟而导致其后面的定时任务延时。计算公式为scheduledExecutionTime(第n+1次) &#x3D; realExecutionTime(第n次) + periodTime。</p><p>也就是说如果第n次执行task时，由于某种原因这次执行时间过长，执行完后的systemCurrentTime&gt;&#x3D; scheduledExecutionTime(第n+1次)，则此时不做时隔等待，立即执行第n+1次task。</p><p>而接下来的第n+2次task的scheduledExecutionTime(第n+2次)就随着变成了realExecutionTime(第n+1次)+periodTime。这个方法更注重保持间隔时间的稳定。</p><h4 id="2-2-4scheduleAtFixedRate保持执行频率的稳定"><a href="#2-2-4scheduleAtFixedRate保持执行频率的稳定" class="headerlink" title="2.2.4scheduleAtFixedRate保持执行频率的稳定"></a><strong>2.2.4scheduleAtFixedRate保持执行频率的稳定</strong></h4><p>scheduleAtFixedRate在反复执行一个task的计划时，每一次执行这个task的计划执行时间在最初就被定下来了，也就是scheduledExecutionTime(第n次)&#x3D;firstExecuteTime +n*periodTime。</p><p>如果第n次执行task时，由于某种原因这次执行时间过长，执行完后的systemCurrentTime&gt;&#x3D; scheduledExecutionTime(第n+1次)，则此时不做period间隔等待，立即执行第n+1次task。</p><p>接下来的第n+2次的task的scheduledExecutionTime(第n+2次)依然还是firstExecuteTime+（n+2)*periodTime这在第一次执行task就定下来了。说白了，这个方法更注重保持执行频率的稳定。</p><p>如果用一句话来描述任务执行超时之后schedule和scheduleAtFixedRate的区别就是：schedule的策略是错过了就错过了，后续按照新的节奏来走；scheduleAtFixedRate的策略是如果错过了，就努力追上原来的节奏（制定好的节奏）。</p><h3 id="2-3Timer的缺陷"><a href="#2-3Timer的缺陷" class="headerlink" title="2.3Timer的缺陷"></a><strong>2.3Timer的缺陷</strong></h3><p>Timer计时器可以定时（指定时间执行任务）、延迟（延迟5秒执行任务）、周期性地执行任务（每隔个1秒执行任务）。但是，Timer存在一些缺陷。首先Timer对调度的支持是基于绝对时间的，而不是相对时间，所以它对系统时间的改变非常敏感。</p><p>其次Timer线程是不会捕获异常的，如果TimerTask抛出的了未检查异常则会导致Timer线程终止，同时Timer也不会重新恢复线程的执行，它会错误的认为整个Timer线程都会取消。同时，已经被安排单尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。故如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。</p><h2 id="3-Schedule"><a href="#3-Schedule" class="headerlink" title="3.@Schedule"></a>3.@Schedule</h2><p>使用spring配合注解的方式是比较方便的一种实现方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行定时任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在启动类上添加@EnableScheduling来开启定时任务。</p><h2 id="4-分布式任务调度"><a href="#4-分布式任务调度" class="headerlink" title="4.分布式任务调度"></a>4.分布式任务调度</h2><p>以上定时任务方案都是针对单机的，只能在单个JVM进程中使用。而现在基本上都是分布式场景，需要一套在分布式环境下高性能、高可用、可扩展的分布式任务调度框架。</p><h3 id="4-1轻量级神器XXL-Job"><a href="#4-1轻量级神器XXL-Job" class="headerlink" title="4.1轻量级神器XXL-Job"></a>4.1轻量级神器XXL-Job</h3><p>介绍： XXL-JOB是美团点评中间件研发工程师许雪里开发的一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。目前已有多家公司接入xxl-job，包括比较知名的大众点评，京东，优信二手车，北京尚德，360金融 (360)，联想集团 (联想)，易信 (网易)等等….<br>官网地址：<a href="https://github.com/xuxueli/xxl-job">GitHub - xuxueli&#x2F;xxl-job: A distributed task scheduling framework.（分布式任务调度平台XXL-JOB）</a></p><p>源码下载地址： GitHub - xuxueli&#x2F;xxl-job at 2.2.0  </p><p>（1）打开XXL-job源码包xxl-job-executor-samples下xxl-job-executor-sample-springboot；</p><p>（2）修改application.properties文件，修改调度中心Ip；<br>（3） 数据库准备 数据库脚本在doc路径下，将其执行之后可以创建一个数据库。</p><p>配置完文件后，启动项目，访问<a href="http://localhost:8080/xxl-job-admin%E8%BF%9B%E5%85%A5%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E3%80%82%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7/%E5%AF%86%E7%A0%81%EF%BC%9Aadmin/123456%E3%80%82">http://localhost:8080/xxl-job-admin进入管理页面。默认账号/密码：admin/123456。</a></p><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--xxl-job--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8881</span><br><span class="line"></span><br><span class="line">xxl:</span><br><span class="line">  job:</span><br><span class="line">    admin:</span><br><span class="line">      addresses: http://localhost:8080/xxl-job-admin</span><br><span class="line">    executor:</span><br><span class="line">      appname: yyh-ff-app</span><br><span class="line">      port: 9999</span><br></pre></td></tr></table></figure><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还是那个Hello</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;ffyhj&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloJob</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;简单任务执行了。。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样简单的定时任务就完成了。可以通过管理页面配置定时规则，通知定时任务执行。</p><p>详细的管理配置可以参考官方文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java定时任务&quot;&gt;&lt;a href=&quot;#Java定时任务&quot; class=&quot;headerlink&quot; title=&quot;Java定时任务&quot;&gt;&lt;/a&gt;Java定时任务&lt;/h1&gt;&lt;p&gt;在大多数项目中，定时任务都是不可或缺的，定时发放优惠券、定时刷新数据、定时发送邮件等等；在J</summary>
      
    
    
    
    
    <category term="定时任务 xxl-job" scheme="https://wangchengji.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://wangchengji.github.io/fwzssd/b543ced0.html"/>
    <id>https://wangchengji.github.io/fwzssd/b543ced0.html</id>
    <published>2022-09-26T04:51:56.000Z</published>
    <updated>2022-09-27T00:20:02.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-MQ简介"><a href="#1-MQ简介" class="headerlink" title="1.MQ简介"></a>1.MQ简介</h2><p>MQ全称为Message Queue-消息队列，是一种应用程序对应用程序的消息通信，一端只管往队列不断发布信息，另一端只管往队列中读取消息，发布者不需要关心读取消息的谁，读取消息者不需要关心发布消息的是谁，各干各的互不干扰。你可以把它想像成一个邮局，你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。</p><h3 id="1-1MQ的工作模型"><a href="#1-1MQ的工作模型" class="headerlink" title="1.1MQ的工作模型"></a>1.1MQ的工作模型</h3><p>提供者，消费者，MQ队列</p><h3 id="1-2MQ作用"><a href="#1-2MQ作用" class="headerlink" title="1.2MQ作用"></a>1.2MQ作用</h3><p>应用解耦、异步、流量削锋、数据分发、错峰流控、日志收集等等…</p><ul><li><p><strong>解耦：</strong>如果使用feign来实现服务间通信，在服务A中调用了服务B的接口，则服务A和服务B之间就形成了耦合，服务A的运行就依赖于服务B，而如果A服务使用MQ把消息发送给MQ队列，MQ队列再把消息发送给消费者进行消费，A服务就只需要把消息发送给队列即可，即使服务B没有运行，也不影响服务A的运行。</p></li><li><p><strong>异步：</strong>同样是使用上面这个例子，假设服务A的业务执行时间是50ms，服务B的业务执行时间是100ms，如果是使用feign进行同步调用的话，整个服务A执行完就需要至少150ms，而如果使用MQ进行异步调用的话，服务A就只需要完成自己的业务和发送消息到MQ队列即可，不要等待服务B执行完成，实现了一个异步的调用，提高了接口的执行效率。</p></li><li><p><strong>流量削锋：</strong>在秒杀这种高并发的场景下，每秒都有可能产生几万甚至十几万条消息，如果没有对消息处理量进行任何限制的话，很有可能因为过多的消息堆积从而导致消费者宕机的情况。因此官网建议对每一个消息消费者都设置处理消息总数（<strong>消息抓取总数</strong>）。</p><p>消息抓取总数的值，设置过大或者过小都不好，过小的话，会导致整个系统消息吞吐能力下降，造成性能浪费。过大的话，则很有可能导致消息过多，导致整个系统OOM。因此官网建议每一个消费者将该值设置在100-300之间。</p><p>通俗点说就是，如果生产者发送了大量的消息到MQ队列，而如果不做处理的话，消费者会一直接收这庞大的消息，最终把自己压垮，所以可以设置消费者预抓取消息，在自己承受范围之内慢慢的抓取消费消息，同时为了防止消息堆积，可以再新增几个消费者。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置预抓取总数</span></span><br><span class="line">channel.basicQos(<span class="number">300</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>日志处理：</strong>日志存储在消息队列中，用来处理日志，比如kafka。</p></li></ul><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h2><h3 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h3><p>RabbitMQ是一个实现了AMQP（Advanced Message Queuing Protocol）高级消息队列协议的消息队列服务，用Erlang语言。是面向消息的中间件。</p><h4 id="2-1-1安装部署"><a href="#2-1-1安装部署" class="headerlink" title="2.1.1安装部署"></a>2.1.1安装部署</h4><p>详情可以参考：<a href="https://hub.docker.com/_/rabbitmq">https://hub.docker.com/_/rabbitmq</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在线安装</span><br><span class="line">docker pull rabbitmq:management</span><br><span class="line">#使用官方定义的端口号启动</span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><h4 id="2-1-2练习小Demo"><a href="#2-1-2练习小Demo" class="headerlink" title="2.1.2练习小Demo"></a>2.1.2练习小Demo</h4><h5 id="2-1-2-1导入依赖"><a href="#2-1-2-1导入依赖" class="headerlink" title="2.1.2.1导入依赖"></a>2.1.2.1导入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-1-2-2配置文件application-yml"><a href="#2-1-2-2配置文件application-yml" class="headerlink" title="2.1.2.2配置文件application.yml"></a>2.1.2.2配置文件application.yml</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 106.14.18.189</span><br><span class="line">    port: 5672</span><br><span class="line">    virtual-host: /</span><br><span class="line">    username: xxxx</span><br><span class="line">    password: xxxx</span><br><span class="line">    listener:</span><br></pre></td></tr></table></figure><h5 id="2-1-2-2创建生产者和消费者"><a href="#2-1-2-2创建生产者和消费者" class="headerlink" title="2.1.2.2创建生产者和消费者"></a>2.1.2.2创建生产者和消费者</h5><p><strong>消费者：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;106.14.18.189&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.2.建立连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 3.创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 4.订阅消息</span></span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                   AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 5.处理消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;106.14.18.189&quot;</span>);</span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    factory.setUsername(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    factory.setPassword(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.2.建立连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 3.创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 4.发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;小飞棍来喽&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-3整合spring注解方式"><a href="#2-1-2-3整合spring注解方式" class="headerlink" title="2.1.2.3整合spring注解方式"></a>2.1.2.3整合spring注解方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 队列名称</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;object.queue&quot;</span>;</span><br><span class="line">       <span class="comment">// 消息</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;小飞棍来喽&quot;</span>;</span><br><span class="line">       <span class="comment">// 发送消息</span></span><br><span class="line">       rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">   <span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueueMessage1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;接收消息【&quot;</span>+msg+<span class="string">&quot;】&quot;</span>+ LocalDateTime.now());</span><br><span class="line">       Thread.sleep(<span class="number">20</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2RabbitMQ的工作模式"><a href="#2-2RabbitMQ的工作模式" class="headerlink" title="2.2RabbitMQ的工作模式"></a>2.2RabbitMQ的工作模式</h3><h4 id="2-2-1Hello-World简单模型"><a href="#2-2-1Hello-World简单模型" class="headerlink" title="2.2.1Hello World简单模型"></a>2.2.1Hello World简单模型</h4><p>一对一消费，只有一个消费者能接收到</p><p><img src="https://pic1.imgdb.cn/item/633162c416f2c2beb1a9e79f.png"></p><p>上述demo就是使用的简单描述。</p><h4 id="2-2-2Work-queues工作队列"><a href="#2-2-2Work-queues工作队列" class="headerlink" title="2.2.2Work queues工作队列"></a>2.2.2Work queues工作队列</h4><p>多个消费者，你一个我一个分配消费消息，有预取机制，默认公平消费，可配置能者多劳模式，谁完成的快，谁多做一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 106.14.18.189</span><br><span class="line">    port: 5672</span><br><span class="line">    virtual-host: /</span><br><span class="line">    username: xxxx</span><br><span class="line">    password: xxxx</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        prefetch: 1 # 能者多劳，每次只能获取一条，处理完成才能获取下一条</span><br></pre></td></tr></table></figure><p><img src="https://pic1.imgdb.cn/item/633166f316f2c2beb1ae274e.png"></p><p>参考练习demo，在其基础上再创建一个或多个消费者即可。</p><h4 id="2-2-3Publish-x2F-Subscribe发布订阅模型"><a href="#2-2-3Publish-x2F-Subscribe发布订阅模型" class="headerlink" title="2.2.3Publish&#x2F;Subscribe发布订阅模型"></a>2.2.3Publish&#x2F;Subscribe发布订阅模型</h4><p>发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。<br> 实现方式是加入了exchange(交换机)，注意：交换机是不缓存消息的</p><p><img src="https://pic1.imgdb.cn/item/63316a5616f2c2beb1b2089f.png"></p><p>声明交换机和队列，并绑定关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个fanout交换机</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//声明一个消息队列1</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanoutQueue1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绑定交换机和队列1</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(FanoutExchange fanoutExchange,Queue fanoutQueue1)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder</span><br><span class="line">               .bind(fanoutQueue1)</span><br><span class="line">               .to(fanoutExchange);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//声明一个消息队列2</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanoutQueue2&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绑定交换机和队列2</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(FanoutExchange fanoutExchange,Queue fanoutQueue2)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder</span><br><span class="line">               .bind(fanoutQueue2)</span><br><span class="line">               .to(fanoutExchange);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanoutQueue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fanoutQueue1收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanoutQueue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fanoutQueue2收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fanout向交换机发送消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 交换机名字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fanoutQueueName</span> <span class="operator">=</span> <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(fanoutQueueName,<span class="string">&quot;&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4Routing路由模型"><a href="#2-2-4Routing路由模型" class="headerlink" title="2.2.4Routing路由模型"></a>2.2.4Routing路由模型</h4><p>routing模型也是将消息发送到交换机</p><p>使用的是Direct类型的交换机，会将接收到的消息<code>根据规则路由到指定的Queue</code>(队列)，因此称为路由模式</p><p><img src="https://pic1.imgdb.cn/item/63316b1a16f2c2beb1b3445d.png"></p><p>可以通过@RabbitListener注解，声明消费者的同时创建交换机和队列并绑定关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;directQueue1&quot;)</span></span><br><span class="line"><span class="meta">        ,exchange = @Exchange(name = &quot;direct&quot;,type = ExchangeTypes.DIRECT)</span></span><br><span class="line"><span class="meta">        ,key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;directQueue1收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(value = @Queue(name = &quot;directQueue2&quot;)</span></span><br><span class="line"><span class="meta">        ,exchange = @Exchange(name = &quot;direct&quot;,type = ExchangeTypes.DIRECT)</span></span><br><span class="line"><span class="meta">        ,key = &#123;&quot;red&quot;,&quot;yellow&quot;&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;directQueue2收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//direct向交换机发送消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 交换机名字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fanoutQueueName</span> <span class="operator">=</span> <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, yellow&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="comment">//rabbitTemplate.convertAndSend(fanoutQueueName,&quot;blue&quot;,message);</span></span><br><span class="line">    <span class="comment">//rabbitTemplate.convertAndSend(fanoutQueueName,&quot;red&quot;,message);</span></span><br><span class="line">    rabbitTemplate.convertAndSend(fanoutQueueName,<span class="string">&quot;yellow&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5Topics主题模型"><a href="#2-2-5Topics主题模型" class="headerlink" title="2.2.5Topics主题模型"></a>2.2.5Topics主题模型</h4><p>topicExchange与directExchange类型，区别在于routingKey必须是多个单词的列表，并且以 . 分隔</p><p>*（代表通配符，任意一个字段）<br>#（号代表一个或多个字段)</p><p><img src="https://pic1.imgdb.cn/item/63316d2116f2c2beb1b581cf.png"></p><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topicQueue1&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;*.orange.*&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;topicQueue1收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topicQueue2&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;topic&quot;,type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">        key = &quot;lazy.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;topicQueue2收到消息&quot;</span>+msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//topic向交换机发送消息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 交换机名字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fanoutQueueName</span> <span class="operator">=</span> <span class="string">&quot;topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message1</span> <span class="operator">=</span> <span class="string">&quot;send to lazy&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> <span class="string">&quot;send to orange&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(fanoutQueueName,<span class="string">&quot;lazy.msg&quot;</span>,message1);</span><br><span class="line">    rabbitTemplate.convertAndSend(fanoutQueueName,<span class="string">&quot;send.orange.msg&quot;</span>,message2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-6消息转换器"><a href="#2-2-6消息转换器" class="headerlink" title="2.2.6消息转换器"></a>2.2.6消息转换器</h4><p>代码里直接<code>发送对象</code>，虽然接收的到消息，但是rabbitmq的界面上看到的消息会是乱码，需要消息转换器。</p><p><strong>依赖：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3延迟消息"><a href="#2-3延迟消息" class="headerlink" title="2.3延迟消息"></a>2.3延迟消息</h3><h4 id="2-3-1基于插件延迟队列"><a href="#2-3-1基于插件延迟队列" class="headerlink" title="2.3.1基于插件延迟队列"></a>2.3.1基于插件延迟队列</h4><p>延迟队列非常常用且好用，可以将<code>消息发送后使消费者延迟接收</code>。</p><p><img src="https://pic1.imgdb.cn/item/6331705d16f2c2beb1b8b3de.png"></p><p><strong><code>RabbitAdmin配置</code></strong></p><p>RabbitAdmin是用于对交换机和队列进行管理，用于创建、绑定、删除队列与交换机，发送消息的组件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAdminConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.rabbitmq.host&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String host;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.rabbitmq.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.rabbitmq.password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.rabbitmq.virtualhost&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String virtualhost;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ConnectionFactory <span class="title function_">connectionFactory</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">CachingConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingConnectionFactory</span>();</span><br><span class="line">connectionFactory.setAddresses(host);</span><br><span class="line">connectionFactory.setUsername(username);</span><br><span class="line">connectionFactory.setPassword(password);</span><br><span class="line">connectionFactory.setVirtualHost(virtualhost);</span><br><span class="line"><span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitAdmin <span class="title function_">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line"><span class="type">RabbitAdmin</span> <span class="variable">rabbitAdmin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitAdmin</span>(connectionFactory);</span><br><span class="line">rabbitAdmin.setAutoStartup(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> rabbitAdmin;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>封装发送延迟队列工具类</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.CustomExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueue</span> &#123;</span><br><span class="line"><span class="comment">// routingKey</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="comment">// 延迟队列交换机</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送延迟队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 延迟时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayedQueue</span><span class="params">(String queueName, Object params, Integer expiration)</span> &#123;</span><br><span class="line"><span class="comment">// 先创建一个队列</span></span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName);</span><br><span class="line">rabbitAdmin.declareQueue(queue);</span><br><span class="line"><span class="comment">// 创建延迟队列交换机</span></span><br><span class="line"><span class="type">CustomExchange</span> <span class="variable">customExchange</span> <span class="operator">=</span> createCustomExchange();</span><br><span class="line">rabbitAdmin.declareExchange(customExchange);</span><br><span class="line"><span class="comment">// 将队列和交换机绑定</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">rabbitAdmin.declareBinding(binding);</span><br><span class="line"><span class="comment">// 发送延迟消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(DELAYED_EXCHANGE, DELAYED_ROUTING_KEY, params, msg -&gt; &#123;</span><br><span class="line"><span class="comment">// 发送消息的时候 延迟时长</span></span><br><span class="line">msg.getMessageProperties().setDelay(expiration);</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">createCustomExchange</span><span class="params">()</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> * 1.交换机的名称</span></span><br><span class="line"><span class="comment"> * 2.交换机的类型</span></span><br><span class="line"><span class="comment"> * 3.是否需要持久化</span></span><br><span class="line"><span class="comment"> * 4.是否自动删除</span></span><br><span class="line"><span class="comment"> * 5.其它参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE,<span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>生产者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DelayedQueue delayedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送延迟队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 延迟时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delayedTest8</span><span class="params">()</span> &#123;</span><br><span class="line">delayedQueue.sendDelayedQueue(<span class="string">&quot;delayTest2&quot;</span>,<span class="string">&quot;这是消息&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>消费者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;delayTest2&quot;,durable = &quot;true&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">declareExchange2</span><span class="params">(String message)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;delayTest2 = &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2TTL队列"><a href="#2-3-2TTL队列" class="headerlink" title="2.3.2TTL队列"></a>2.3.2TTL队列</h4><p>TTL是time to live的缩写，生存时间，RabbitMQ支持消息的过期时间，消息发送时可以指定，从消息入队列开始计算，只要超过队列的<code>超时时间配置，消息没被接收，消息就会自动清除</code></p><p><strong><code>封装发送TTL队列工具类</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueue</span> &#123;</span><br><span class="line"><span class="comment">// routingKey</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_KEY</span> <span class="operator">=</span> <span class="string">&quot;ttl.routingkey&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TTL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;ttl.exchange&quot;</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">RabbitAdmin rabbitAdmin;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送TTL队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 过期时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTtlQueue</span><span class="params">(String queueName, Object params, Integer expiration)</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -----------先创建一个ttl队列------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 队列设置存活时间，单位ms,必须是整形数据。</span></span><br><span class="line">map.put(<span class="string">&quot;x-message-ttl&quot;</span>,expiration);</span><br><span class="line"><span class="comment">/*参数1：队列名称  参数2：持久化  参数3：是否排他 参数4：自动删除队列  参数5：队列参数*/</span></span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,map);</span><br><span class="line">rabbitAdmin.declareQueue(queue);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * --------------创建交换机--------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(TTL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">rabbitAdmin.declareExchange(directExchange);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * --------------队列绑定交换机------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将队列和交换机绑定</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> BindingBuilder.bind(queue).to(directExchange).with(TTL_KEY);</span><br><span class="line">rabbitAdmin.declareBinding(binding);</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(TTL_EXCHANGE,TTL_KEY,params);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>生产者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TtlQueue ttlQueue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送TTL队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 过期时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ttlQueueTest10</span><span class="params">()</span> &#123;</span><br><span class="line">ttlQueue.sendTtlQueue(<span class="string">&quot;ttlQueue&quot;</span>,<span class="string">&quot;这是消息内容&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>消费者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;ttlQueue&quot; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ttlQueue</span><span class="params">(String message)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3死信队列"><a href="#2-3-3死信队列" class="headerlink" title="2.3.3死信队列"></a>2.3.3死信队列</h4><p>DLX，全称为Dead-Letter-Exchange，可以称之为死信交换器。队列消息变成死信(deadmessage)之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。<br>消息变成死信的几种情况：</p><p>   1.消息被拒绝（basic.reject&#x2F; basic.nack）并且requeue&#x3D;false<br>2. 消息TTL过期<br>3. 队列达到最大长度</p><p>流程：发送消息，消息过期后进入到另一个队列（这个队列设置持久化，不过期）的过程。<br><strong><code>封装发送死信队列工具类</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLXQueue</span> &#123;</span><br><span class="line"><span class="comment">// routingKey</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;dead.routingkey&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;routingkey&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;common.exchange&quot;</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">RabbitAdmin rabbitAdmin;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送死信队列，过期后进入死信交换机，进入死信队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deadQueueName 死信队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 过期时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDLXQueue</span><span class="params">(String queueName, String deadQueueName,Object params, Integer expiration)</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ------------先创建一个ttl队列和死信队列-------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 队列设置存活时间，单位ms,必须是整形数据。</span></span><br><span class="line">map.put(<span class="string">&quot;x-message-ttl&quot;</span>,expiration);</span><br><span class="line"><span class="comment">// 设置死信交换机</span></span><br><span class="line">map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">// 设置死信交换器路由键</span></span><br><span class="line">map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_ROUTING_KEY);</span><br><span class="line"><span class="comment">/*参数1：队列名称  参数2：持久化  参数3：是否排他 参数4：自动删除队列  参数5：队列参数*/</span></span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,map);</span><br><span class="line">rabbitAdmin.declareQueue(queue);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -----------创建交换机-------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">rabbitAdmin.declareExchange(directExchange);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ----------队列绑定交换机------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> BindingBuilder.bind(queue).to(directExchange).with(ROUTING_KEY);</span><br><span class="line">rabbitAdmin.declareBinding(binding);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * --------在创建一个死信交换机和队列，接收死信队列---------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">DirectExchange</span> <span class="variable">deadExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(DEAD_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">rabbitAdmin.declareExchange(deadExchange);</span><br><span class="line"></span><br><span class="line"><span class="type">Queue</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(deadQueueName,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">rabbitAdmin.declareQueue(deadQueue);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * --------------队列绑定死信交换机-----------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将队列和交换机绑定</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">deadbinding</span> <span class="operator">=</span> BindingBuilder.bind(deadQueue).to(deadExchange).with(DEAD_ROUTING_KEY);</span><br><span class="line">rabbitAdmin.declareBinding(deadbinding);</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">rabbitTemplate.convertAndSend(EXCHANGE,ROUTING_KEY,params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>生产者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DLXQueue dlxQueue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送死信队列，过期后进入死信交换机，进入死信队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueName 队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deadQueueName 死信队列名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 消息内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expiration 过期时间 毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dlxQueueTest11</span><span class="params">()</span> &#123;</span><br><span class="line">dlxQueue.sendDLXQueue(<span class="string">&quot;queue&quot;</span>,<span class="string">&quot;deadQueue&quot;</span>,<span class="string">&quot;这是消息内容&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>消费者</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收转移后的队列消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(value = &quot;deadQueue&quot;,durable = &quot;true&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ttlQueue</span><span class="params">(String message)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4常用的其他MQ"><a href="#2-4常用的其他MQ" class="headerlink" title="2.4常用的其他MQ"></a>2.4常用的其他MQ</h3><table><thead><tr><th></th><th align="center">RabbitMQ</th><th align="center">ActiveMQ</th><th align="center">RocketMQ</th><th align="center">Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td align="center">Rabbit</td><td align="center">Apache</td><td align="center">阿里</td><td align="center">Apache</td></tr><tr><td>开发语言</td><td align="center">Erlang</td><td align="center">Java</td><td align="center">Java</td><td align="center">Scala&amp;Java</td></tr><tr><td>协议支持</td><td align="center">AMQP,XMPP,SMTP,STOMP</td><td align="center">OpenWire，STOMP，REST，XMPP,AMQP</td><td align="center">自定义</td><td align="center">自定义</td></tr><tr><td>可用性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">高</td></tr><tr><td>单机吞吐量</td><td align="center">一般</td><td align="center">差</td><td align="center">高</td><td align="center">非常高</td></tr><tr><td>消息延迟</td><td align="center">微妙级</td><td align="center">毫秒级</td><td align="center">毫秒级</td><td align="center">毫秒以内</td></tr><tr><td>消息可靠性</td><td align="center">高</td><td align="center">一般</td><td align="center">高</td><td align="center">一般</td></tr></tbody></table><h3 id="2-5常见问题"><a href="#2-5常见问题" class="headerlink" title="2.5常见问题"></a>2.5常见问题</h3><h4 id="2-5-1消息丢失问题"><a href="#2-5-1消息丢失问题" class="headerlink" title="2.5.1消息丢失问题"></a>2.5.1消息丢失问题</h4><p>按照现有rabbitMQ的相关知识，生产者会发送消息到达消息服务器。但是在实际生产环境下，消息生产者发送的消息很有可能当到达了消息服务器之后，由于消息服务器的问题导致消息丢失，如宕机。因为消息服务器默认会将消息存储在内存中。一旦消息服务器宕机，则消息会产生丢失。因此要保证生产者的消息不丢失，要开始持久化策略。</p><p><strong>rabbitMQ持久化：</strong><br>    交换机持久化<br>    队列持久化<br>    消息持久化</p><p>但是如果仅仅只是开启这两部分的持久化，也很有可能造成消息丢失。因为消息服务器很有可能在持久化的过程中出现宕机。因此需要通过数据保护机制来保证消息一定会成功进行持久化，否则将一直进行消息发送。</p><p><strong>RabbitMQ数据保护机制</strong><br>  <strong>事务机制</strong><br>    事务机制采用类数据库的事务机制进行数据保护，当消息到达消息服务器，首先会开启一个事务，接着进行数据磁盘持久化，只有持久化成功才会进行事务提交，向消息生产者返回成功通知，消息生产者一旦接收成功通知则不会再发送此条消息。当出现异常，则返回失败通知.消息生产者一旦接收失败通知，则继续发送该条消息。<br>    事务机制虽然能够保证数据安全，但是此机制采用的是同步机制，会产生系统间消息阻塞，影响整个系统的消息吞吐量。从而导致整个系统的性能下降，因此不建议使用。<br>  <strong>confirm机制</strong><br>    confirm模式需要基于channel进行设置, 一旦某条消息被投递到队列之后,消息队列就会发送一个确认信息给生产者,如果队列与消息是可持久化的, 那么确认消息会等到消息成功写入到磁盘之后发出。<br>    confirm的性能高,主要得益于它是异步的.生产者在将第一条消息发出之后等待确认消息的同时也可以继续发送后续的消息.当确认消息到达之后,就可以通过回调方法处理这条确认消息. 如果MQ服务宕机了,则会返回nack消息. 生产者同样在回调方法中进行后续处理。</p><h4 id="2-5-2如何保证消息的有序性"><a href="#2-5-2如何保证消息的有序性" class="headerlink" title="2.5.2如何保证消息的有序性"></a>2.5.2如何保证消息的有序性</h4><p>1.保证只有一个消费者        </p><p>2.给消息添加一个消费的顺序编号，通过编号来确定谁先消费。</p><h4 id="2-5-3MQ如何防止重复消息（消息的幂等）"><a href="#2-5-3MQ如何防止重复消息（消息的幂等）" class="headerlink" title="2.5.3MQ如何防止重复消息（消息的幂等）"></a>2.5.3MQ如何防止重复消息（消息的幂等）</h4><p>使用redis，在生产者发送消息时在redis中生成一个key（建议是zset，设置大小为1），把这个key放到消息中传递给消费者，消费者在消费消息前先判断该消息的值是否已经被消费过，即判断传入的key是否存在和zset的大小是否是1，如果不存在该key或者值的大小不为1，则代表该消息已执行抛弃这条消息，不然则对zset的值进行increment，在执行完业务后，再把这个key删除，这样就防止了消息的重复消费。（并不是所有的业务都要做幂等判断，要根据业务来设计）</p><h4 id="2-5-4如何防止请求的洪灾（削锋）"><a href="#2-5-4如何防止请求的洪灾（削锋）" class="headerlink" title="2.5.4如何防止请求的洪灾（削锋）"></a>2.5.4如何防止请求的洪灾（削锋）</h4><p> 设置MQ的预抓取总数（channel.basicQos(200); &#x2F;&#x2F;代表每次预抓取200条消息），把MQ主动推送消息变成消费方手主动抓取消息。</p><h4 id="2-5-5如何解决MQ的消息堆积"><a href="#2-5-5如何解决MQ的消息堆积" class="headerlink" title="2.5.5如何解决MQ的消息堆积"></a>2.5.5如何解决MQ的消息堆积</h4><p>1.增加消费者。    2.多线程消费（使用线程池，异步处理消费的消息业务，即加快消费者的效率）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-MQ简介&quot;&gt;&lt;a href=&quot;#1-MQ简介&quot; class=&quot;headerlink&quot; title=&quot;1.MQ简介&quot;&gt;&lt;/a&gt;1.MQ简介&lt;/h2&gt;&lt;p&gt;MQ全称为Message Queue-消息队列，是一种应用程序对应用程序的消息通信，一端只管往队列不断发布信</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="https://wangchengji.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8新特性</title>
    <link href="https://wangchengji.github.io/fwzssd/d111bf74.html"/>
    <id>https://wangchengji.github.io/fwzssd/d111bf74.html</id>
    <published>2022-09-25T04:23:51.000Z</published>
    <updated>2022-09-26T03:45:23.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h1><p>jdk1.8新特性：</p><ul><li><strong>Lambda表达式</strong></li><li><strong>函数式接口</strong></li><li><strong>方法引用和构造器调用</strong></li><li><strong>Stream API</strong></li><li><strong>接口中的默认方法和静态方法</strong></li><li><strong>新时间日期API</strong></li><li><strong>Optional类</strong></li></ul><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h2><p>lambda<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>本质上是一段匿名内部类，也可以是一段可以传递的代码。</p><p>相较于匿名内部类Lambda表达式更加优雅，减少了代码量，如下示例，创建User的有序集合，按年龄和姓名排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        TreeSet&lt;User&gt; set1 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User user1, User user2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> user1.getAge() - user2.getAge();</span><br><span class="line">                result = result == <span class="number">0</span> ? user1.getName().compareTo(user2.getName()) : result;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zs&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        set1.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ls&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        System.out.println(set1);</span><br><span class="line">        <span class="comment">//使用lambda表达式</span></span><br><span class="line">        TreeSet&lt;User&gt; set2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((user1, user2) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> user1.getAge() - user2.getAge();</span><br><span class="line">            result = result == <span class="number">0</span> ? user1.getName().compareTo(user2.getName()) : result;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        set2.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ww&quot;</span>,<span class="number">26</span>));</span><br><span class="line">        set2.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zl&quot;</span>,<span class="number">27</span>));</span><br><span class="line">        System.out.println(set2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述示例看上去可能并没有减少多少代码，其实set2可以继续简化为一行如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;User&gt; set2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((user1, user2) -&gt;(user1.getAge() - user2.getAge()) == <span class="number">0</span> ? user1.getName().compareTo(user2.getName()) : (user1.getAge() - user2.getAge()));</span><br></pre></td></tr></table></figure><p>匿名内部类编译后会单独生成一个.class字节码文件存在于硬盘中。而Lambda表达式不会单独生成.class字节码文件，而是随着运行时动态生成.class字节码文件，且不会存在于硬盘中。</p><p>Lambda表达式只能操作接口，且只能操作只有一个抽象方法的接口，也就是下面要说的函数式接口。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h2><p>有且仅有一个抽象方法的接口叫做函数式接口，函数式接口可以被隐式转换为Lambda表达式。通常函数式接口上会添加@FunctionalInterface 注解校验是否是函数式接口。</p><h3 id="2-1jdk内置的函数式接口"><a href="#2-1jdk内置的函数式接口" class="headerlink" title="2.1jdk内置的函数式接口"></a>2.1jdk内置的函数式接口</h3><ul><li><h4 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h4></li></ul><p><strong>接口名称：</strong>Consumer</p><p><strong>抽象方法</strong>：void accept(T t)：消费一个参数数据</p><p><strong>概述</strong>：该接口中的方法可以接收一个参数，接收的参数类型由泛型指定，对参数的操作 方式根据该接口的实现类决定，不需要返回值。</p><ul><li><h4 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h4></li></ul><p><strong>接口名：</strong>Supplier </p><p><strong>抽象方法：</strong>T get()：该方法不需要参数，它会按照某种逻辑，返回一个具体的数据</p><p><strong>概述：</strong>该接口也被称为生产型接口，如果指定了泛型是什么类型，那类中的get方法就会返回 一个该类型的一个具体数据。返回的数据，由该接口的实现类对象决定。</p><ul><li><h4 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h4></li></ul><p><strong>接口名：</strong>Function&lt;T,R&gt;</p><p><strong>抽象方法：</strong>R apply(T)：接收一个数据，操作数据之后，返回一个新的数据</p><p><strong>概述：</strong>该接口可以接收一个数据，数据的类型根据泛型指定，然后通过该接口的实现类对象对 该数据进行操作，操作之后返回一个新的数据。</p><ul><li><h4 id="断言型接口"><a href="#断言型接口" class="headerlink" title="断言型接口"></a>断言型接口</h4></li></ul><p><strong>接口名：</strong>Predicate</p><p><strong>抽象方法：</strong>boolean test(T t)：对数据做出指定的判断</p><p><strong>概述：</strong>该接口是一个判断接口，接口可以接收一个指定泛型的参数，并根据该接口的实现类 对象对该参数做出对应的判断，返回只为boolean类型</p><p><strong>额外功能：</strong>and(Predicate p)：先将参数通过调用者判断真假，再将参数通过p判断真假，全真 为真，否则为假or(Predicate p):全假为假，否则为真negate():取反。</p><h2 id="3-方法引用和构造器调用"><a href="#3-方法引用和构造器调用" class="headerlink" title="3.方法引用和构造器调用"></a>3.<strong>方法引用和构造器调用</strong></h2><p><strong>概念：</strong>对lambda表达式的扩展，在定义lambda表达式的内容时，如果这个内容之前已经定 义过，那么就不需要再定义一遍，直接调用即可。</p><p><strong>格式：</strong></p><p>如果是一个构造方法：类名：：new</p><p>如果是一个静态方法：类名：：方法名</p><p>如果是一个非静态方法：对象名：：方法名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//引用构造方法</span></span><br><span class="line">        Consumer&lt;String&gt; con = User::<span class="keyword">new</span>;</span><br><span class="line">        con.accept(<span class="string">&quot;引用构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//引用静态方法</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = User::show;</span><br><span class="line">        con1.accept(<span class="string">&quot;引用静态方法&quot;</span>);</span><br><span class="line">        <span class="comment">//引用非静态方法</span></span><br><span class="line">        Consumer&lt;String&gt; con2 = <span class="keyword">new</span> <span class="title class_">User</span>()::show1;</span><br><span class="line">        con2.accept(<span class="string">&quot;引用非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MybitsPlus中也用到了方法引用，如下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">     User <span class="title function_">getUser</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service实现类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        userLambdaQueryWrapper.eq(User::getName,name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getOne(userLambdaQueryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4.Stream API"></a><strong>4.Stream API</strong></h2><p>新添加的 Stream API（java.util.stream）把真正的函数式编程风格引入到 Java中。这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p><p>比如我想要截取集合中的一段内容，就可以用流的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>  &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">6</span>);</span><br><span class="line">    list.add(<span class="number">7</span>);</span><br><span class="line">    List&lt;Integer&gt; collect = list.stream().skip(<span class="number">2</span>).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-接口允许定义默认方法和静态方法"><a href="#5-接口允许定义默认方法和静态方法" class="headerlink" title="5.接口允许定义默认方法和静态方法"></a>5.接口允许定义默认方法和静态方法</h2><p>从 JDK8 开始，允许接口中存在一个或多个默认非抽象方法和静态方法。从Java 9开始，我们可以在Interface接口中添加private的私有方法和私有静态方法。</p><h2 id="6-新时间日期API"><a href="#6-新时间日期API" class="headerlink" title="6.新时间日期API"></a>6.<strong>新时间日期API</strong></h2><p>JDK8之前的日期存在一些问题，比如API过时、线程安全问题、时区处理麻烦等问题。在JDK8中引入了新的日期时间相关的API。</p><p> JDK8引入了LocalDate、LocalTime、LocalDateTime类，这些类在java.time包下，并且它们的实例是不可变对象。分别使用表示ISO-8601日历系统的日期、时间、日期时间。</p><h3 id="6-1日期"><a href="#6-1日期" class="headerlink" title="6.1日期"></a>6.1日期</h3><p> 日期包含年月日信息，日期的操作的常用API如下</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前对应的日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">//获取年份</span></span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    <span class="comment">//获取月份，英文</span></span><br><span class="line">    System.out.println(now.getMonth());</span><br><span class="line">    <span class="comment">//获取月份值</span></span><br><span class="line">    System.out.println(now.getMonthValue());</span><br><span class="line">    <span class="comment">//获取当月中的第几天，也就是几号</span></span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    <span class="comment">//获取当周中的第几天，也就是星期</span></span><br><span class="line">    System.out.println(now.getDayOfWeek());</span><br><span class="line">    <span class="comment">//获取年中的第几天</span></span><br><span class="line">    System.out.println(now.getDayOfYear());</span><br><span class="line">    <span class="comment">//修改年份为2019</span></span><br><span class="line">    System.out.println(now.withYear(<span class="number">2019</span>));</span><br><span class="line">    <span class="comment">//修改月份为2</span></span><br><span class="line">    System.out.println(now.withMonth(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//修改日期为3号</span></span><br><span class="line">    System.out.println(now.withDayOfMonth(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-时间"><a href="#6-2-时间" class="headerlink" title="6.2 时间"></a>6.2 时间</h3><p>时间包含时分秒信息，时间操作常用的API如下</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="comment">//      获取当前时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="comment">//       获取小时</span></span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">    <span class="comment">//       获取分</span></span><br><span class="line">    System.out.println(now.getMinute());</span><br><span class="line">    <span class="comment">//       获取秒</span></span><br><span class="line">    System.out.println(now.getSecond());</span><br><span class="line">    <span class="comment">//       获取纳秒</span></span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">    <span class="comment">//      修改小时为12</span></span><br><span class="line">    System.out.println(now.withHour(<span class="number">12</span>));</span><br><span class="line">    <span class="comment">//       修改分钟为22</span></span><br><span class="line">    System.out.println(now.withMinute(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//        修改秒为33</span></span><br><span class="line">    System.out.println(now.withSecond(<span class="number">33</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3日期时间"><a href="#6-3日期时间" class="headerlink" title="6.3日期时间"></a>6.3日期时间</h3><p> 日期时间包含年月日时分秒信息，常用API如下</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="comment">//获取年份</span></span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    <span class="comment">//获取月份，英文</span></span><br><span class="line">    System.out.println(now.getMonth());</span><br><span class="line">    <span class="comment">//获取月份值</span></span><br><span class="line">    System.out.println(now.getMonthValue());</span><br><span class="line">    <span class="comment">//获取当月中的第几天，也就是几号</span></span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    <span class="comment">//获取当周中的第几天，也就是星期</span></span><br><span class="line">    System.out.println(now.getDayOfWeek());</span><br><span class="line">    <span class="comment">//获取年中的第几天</span></span><br><span class="line">    System.out.println(now.getDayOfYear());</span><br><span class="line">    <span class="comment">//获取小时</span></span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">    <span class="comment">//获取分</span></span><br><span class="line">    System.out.println(now.getMinute());</span><br><span class="line">    <span class="comment">//获取秒</span></span><br><span class="line">    System.out.println(now.getSecond());</span><br><span class="line">    <span class="comment">//获取纳秒</span></span><br><span class="line">    System.out.println(now.getNano());</span><br><span class="line">    <span class="comment">//修改年份为2019</span></span><br><span class="line">    System.out.println(now.withYear(<span class="number">2019</span>));</span><br><span class="line">    <span class="comment">//修改月份为2</span></span><br><span class="line">    System.out.println(now.withMonth(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//修改日期为3号</span></span><br><span class="line">    System.out.println(now.withDayOfMonth(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//修改小时为12</span></span><br><span class="line">    System.out.println(now.withHour(<span class="number">12</span>));</span><br><span class="line">    <span class="comment">//修改分钟为22</span></span><br><span class="line">    System.out.println(now.withMinute(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//修改秒为33</span></span><br><span class="line">    System.out.println(now.withSecond(<span class="number">33</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tip：</strong>时间跟日期的修改都是返回一个新的日期时间对象，原来的日期时间对象不改变。</p><h3 id="6-4格式化"><a href="#6-4格式化" class="headerlink" title="6.4格式化"></a>6.4格式化</h3><p>可以通过<code>java.time.format.DateTimeFormatter</code>类可以进行日期时间的解析与格式化。</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//日期转成格式化字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">formatNow</span> <span class="operator">=</span> now.format(dtf);</span><br><span class="line">    System.out.println(formatNow);</span><br><span class="line">    <span class="comment">//格式化字符串转成日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021年01月28日 04时14分43秒&quot;</span>, dtf);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5日期时间差"><a href="#6-5日期时间差" class="headerlink" title="6.5日期时间差"></a>6.5日期时间差</h3><p>JDK8中通过<code>Duration </code>用于计算两个“时间”间隔。通过<code>Period</code>用于计算两个“日期”间隔的类。</p><p><strong>Duration代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">17</span>,<span class="number">48</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(now,time);</span><br><span class="line">    <span class="comment">//时间差转成小时</span></span><br><span class="line">    System.out.println(duration.toHours());</span><br><span class="line">    <span class="comment">//时间差转成分钟</span></span><br><span class="line">    System.out.println(duration.toMinutes());</span><br><span class="line">    <span class="comment">//时间差转成秒</span></span><br><span class="line">    System.out.println(duration.getSeconds());</span><br><span class="line">    <span class="comment">//时间差转成纳秒</span></span><br><span class="line">    System.out.println(duration.toNanos());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Period代码演示</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date06</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2030</span>,<span class="number">4</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(now,date);</span><br><span class="line">    <span class="comment">//获取年份差</span></span><br><span class="line">    System.out.println(period.getYears());</span><br><span class="line">    <span class="comment">//获取月份差</span></span><br><span class="line">    System.out.println(period.getMonths());</span><br><span class="line">    <span class="comment">//获取日期差</span></span><br><span class="line">    System.out.println(period.getDays());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-时间校正器"><a href="#6-6-时间校正器" class="headerlink" title="6.6 时间校正器"></a>6.6 时间校正器</h3><p> 有时候我们需要将日期或者时间进行校正，比如设置为“下个月的第1天”等，可以通过时间校正器进行。</p><ul><li>TemporalAdjuster：时间校正器。</li><li>TemporalAdjusters：通过静态方法提供大量的常用的TemporalAdjuster实现。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date07</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//设置下月1号的校正器</span></span><br><span class="line">    <span class="type">TemporalAdjuster</span> <span class="variable">firstDayOfNextMonth</span> <span class="operator">=</span> temporal -&gt; &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> (LocalDateTime) temporal;</span><br><span class="line">        <span class="keyword">return</span> time.plusMonths(<span class="number">1</span>).withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//通过校正器调节now的值</span></span><br><span class="line">    System.out.println(now.with(firstDayOfNextMonth));</span><br><span class="line">    <span class="comment">//TemporalAdjusters获取下一年的第1天的校正器</span></span><br><span class="line">    System.out.println(now.with(TemporalAdjusters.firstDayOfNextYear()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Optional类"><a href="#7-Optional类" class="headerlink" title="7.Optional类"></a>7.Optional类</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p><p>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><p>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测</p><p>创建Optional类对象的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(T t) <span class="comment">//创建一个Optional 实例，t必须非空；</span></span><br><span class="line">Optional.empty() <span class="comment">//创建一个空的Optional 实例</span></span><br><span class="line">Optional.ofNullable(T t)<span class="comment">//t可以为null</span></span><br></pre></td></tr></table></figure><p>判断Optional容器中是否包含对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> <span class="comment">// 判断是否包含对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> <span class="comment">//如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</span></span><br></pre></td></tr></table></figure><p>获取Optional容器的对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">get</span><span class="params">()</span><span class="comment">//如果调用对象包含值，返回该值，否则抛异常</span></span><br><span class="line">T <span class="title function_">orElse</span><span class="params">(T other)</span> <span class="comment">//如果有值则将其返回，否则返回指定的other对象。</span></span><br><span class="line">T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> <span class="comment">//如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</span></span><br><span class="line">T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="comment">//如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK1-8新特性&quot;&gt;&lt;a href=&quot;#JDK1-8新特性&quot; class=&quot;headerlink&quot; title=&quot;JDK1.8新特性&quot;&gt;&lt;/a&gt;JDK1.8新特性&lt;/h1&gt;&lt;p&gt;jdk1.8新特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lambda表达式&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://wangchengji.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>EasyExcel</title>
    <link href="https://wangchengji.github.io/fwzssd/undefined.html"/>
    <id>https://wangchengji.github.io/fwzssd/undefined.html</id>
    <published>2022-09-22T12:47:16.000Z</published>
    <updated>2022-09-24T10:04:17.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h1><p>简介：传统操作Excel大多都是利用Apach POI进行操作的，但是POI框架并不完善，使用过程非常繁琐且有较多的缺陷：动态操作Excel非常繁琐,对于新手来说，很难在短时间内上手;读写时需要占用较大的内存，当数据量大时容易发生内存溢出问题（OOM）;EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能，但其底层依然是使用POI。</p><p>官网地址：<a href="https://www.yuque.com/easyexcel/doc/easyexcel">https://www.yuque.com/easyexcel/doc/easyexcel</a></p><h2 id="1-简单入门"><a href="#1-简单入门" class="headerlink" title="1.简单入门"></a>1.简单入门</h2><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入easyexcel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写pojo类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@HeadRowHeight(value = 40)</span> <span class="comment">//第一行高度</span></span><br><span class="line"><span class="meta">@ColumnWidth(value = 20)</span> <span class="comment">//列宽</span></span><br><span class="line"><span class="meta">@ContentRowHeight(value = 20)</span> <span class="comment">//内容高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;姓名&quot;&#125;,index = 0)</span> <span class="comment">//设置列名 和 位置</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;年龄&quot;&#125;,index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;地址&quot;&#125;,index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生信息表&quot;,&quot;生日&quot;&#125;,index = 3)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(value = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> <span class="comment">//设置时间格式</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写测试（读写数据）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//写数据到表格</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;北京&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">       userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">23</span>,<span class="string">&quot;上海&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">       userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">24</span>,<span class="string">&quot;杭州&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">       userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;赵磊&quot;</span>,<span class="number">21</span>,<span class="string">&quot;南京&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line"></span><br><span class="line">       EasyExcel.write(<span class="string">&quot;D:\\1.xls&quot;</span>,User.class) <span class="comment">//写入路径</span></span><br><span class="line">               .sheet(<span class="string">&quot;学生信息表&quot;</span>)<span class="comment">//表名</span></span><br><span class="line">           .doWrite(userList);<span class="comment">//写入数据</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//读路径</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="string">&quot;\\1.xls&quot;</span>;</span><br><span class="line">       List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//read中还可以传输入流</span></span><br><span class="line">       EasyExcel.read(file, User.class, <span class="keyword">new</span> <span class="title class_">AnalysisEventListener</span>&lt;User&gt;() &#123;</span><br><span class="line">           <span class="comment">//读一条执行一次</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(User o, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">               userList.add(o);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//读完执行</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;数据导入完成&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).sheet(<span class="string">&quot;学生信息表&quot;</span>).doRead();</span><br><span class="line"></span><br><span class="line">       System.out.println(userList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="2-常用注解"><a href="#2-常用注解" class="headerlink" title="2.常用注解"></a>2.常用注解</h2><ol><li><p><strong><code>@ExcelProperty</code></strong></p><p>这是最常用的一个注解，注解中有三个参数**<code>value</code><strong>,</strong><code>index</code><strong>,</strong><code>converter</code><strong>分别代表列明，列序号，数据转换方式，</strong><code>value</code><strong>和</strong><code>index</code><strong>只能二选一，通常不用设置</strong><code>converter</code>**。</p></li><li><p><strong><code>@ColumnWith</code></strong></p><p>用于设置列宽度的注解,注解中只有一个参数value，value的单位是字符长度，最大可以设置255个字符，因为一个excel单元格最大可以写入的字符个数就是255个字符，该注解加类上就是设置整个表格的列宽，加属性上技术设置对应列的列宽。</p></li><li><p><strong><code>@ContentFontStyle</code></strong></p><p>用于设置单元格内容字体格式的注解</p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">fontName</td><td align="center">字体名称</td></tr><tr><td align="center">fontHeightInPoints</td><td align="center">字体高度</td></tr><tr><td align="center">italic</td><td align="center">是否斜体</td></tr><tr><td align="center">strikeout</td><td align="center">是否设置删除水平线</td></tr><tr><td align="center">color</td><td align="center">字体颜色</td></tr><tr><td align="center">typeOffset</td><td align="center">偏移量</td></tr><tr><td align="center">underline</td><td align="center">下划线</td></tr><tr><td align="center">bold</td><td align="center">是否加粗</td></tr><tr><td align="center">charset</td><td align="center">编码格式</td></tr></tbody></table></li><li><p><strong><code>@ContentRowHeight</code></strong></p><p>用于设置行高，-1表示自动行高。</p></li><li><p><strong><code>@ExcelIgnore</code></strong></p><p>不将该字段转换成<strong>Excel</strong>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EasyExcel&quot;&gt;&lt;a href=&quot;#EasyExcel&quot; class=&quot;headerlink&quot; title=&quot;EasyExcel&quot;&gt;&lt;/a&gt;EasyExcel&lt;/h1&gt;&lt;p&gt;简介：传统操作Excel大多都是利用Apach POI进行操作的，但是POI框架并不</summary>
      
    
    
    
    
    <category term="EasyExcel" scheme="https://wangchengji.github.io/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化机制</title>
    <link href="https://wangchengji.github.io/fwzssd/e5adb42e.html"/>
    <id>https://wangchengji.github.io/fwzssd/e5adb42e.html</id>
    <published>2022-09-12T03:31:11.000Z</published>
    <updated>2022-09-12T12:49:09.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h1><h2 id="1-Redis的持久化"><a href="#1-Redis的持久化" class="headerlink" title="1.Redis的持久化"></a>1.Redis的持久化</h2><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1.RDB持久化"></a>1.1.RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1.执行时机"></a>1.1.1.执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>进入redis客户端输入<strong>save</strong>，会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>同样在redis客户端输入<strong>bgsave</strong>命令可以异步执行RDB，这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2.RDB原理"></a>1.1.2.RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://pic.imgdb.cn/item/631ee01f16f2c2beb1392b8d.png"></p><h3 id="1-1-3-小结"><a href="#1-1-3-小结" class="headerlink" title="1.1.3.小结"></a>1.1.3.小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="1-2-AOF持久化"><a href="#1-2-AOF持久化" class="headerlink" title="1.2.AOF持久化"></a>1.2.AOF持久化</h2><h3 id="1-2-1-AOF原理"><a href="#1-2-1-AOF原理" class="headerlink" title="1.2.1.AOF原理"></a>1.2.1.AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><h3 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2.AOF配置"></a>1.2.2.AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略对比：</p><table><thead><tr><th align="center">配置项</th><th align="center">刷盘时间</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">Always</td><td align="center">同步刷盘</td><td align="center">可靠性高，几乎不丢失数据</td><td align="center">性能影响大</td></tr><tr><td align="center">everysec</td><td align="center">每秒刷盘</td><td align="center">性能适中</td><td align="center">最多丢失1秒数据</td></tr><tr><td align="center">no</td><td align="center">操作系统控制</td><td align="center">性能最好</td><td align="center">可靠性差，可能丢失大量数据</td></tr></tbody></table><h3 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3.AOF文件重写"></a>1.2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://pic.imgdb.cn/item/631ef0aa16f2c2beb14ad9b4.png"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3.RDB与AOF对比"></a>1.3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th align="center"></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次执行的命令</td></tr><tr><td align="center">数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，取决于刷盘策略</td></tr><tr><td align="center">文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积很大</td></tr><tr><td align="center">宕机恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td align="center">数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性高</td></tr><tr><td align="center">系统资源占用</td><td align="center">高，大量CPU和内存消耗</td><td align="center">低,主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td align="center">使用场景</td><td align="center">可以容忍数分钟的数据丢失，追求更加快的启动速度</td><td align="center">对数据安全性要求较高</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis的持久化机制&quot;&gt;&lt;a href=&quot;#Redis的持久化机制&quot; class=&quot;headerlink&quot; title=&quot;Redis的持久化机制&quot;&gt;&lt;/a&gt;Redis的持久化机制&lt;/h1&gt;&lt;h2 id=&quot;1-Redis的持久化&quot;&gt;&lt;a href=&quot;#1-Redi</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的过期键删除策略</title>
    <link href="https://wangchengji.github.io/fwzssd/197f8.html"/>
    <id>https://wangchengji.github.io/fwzssd/197f8.html</id>
    <published>2022-09-09T07:25:35.000Z</published>
    <updated>2022-09-11T12:03:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是一种基于内存的高性能键值对(key-value)数据库，而内存的资源相对来说还是比较宝贵的，所以Redis需要定期删除数据库中过期的键值对。</p><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>Redis的删除策略有以下3种：</p><ul><li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li><strong>惰性删除</strong>：放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键。</li><li><strong>定期删除</strong>：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定。</li></ul><p>其中定时删除和定期删除为主动删除策略，惰性删除为被动删除策略。</p><h3 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h3><p>定时删除策略是使用定时器。定时删除策略可以保证过期键尽可能快地被删除，并释放过期键占用的内存。</p><p>因此，定时删除策略的优缺点如下所示：</p><ul><li>优点：对内存非常友好</li><li>缺点：对CPU时间非常不友好</li></ul><p>举个例子，如果有大量的命令请求等待服务器处理，并且服务器当前不缺少内存，如果服务器将大量的CPU时间用来删除过期键，那么服务器的响应时间和吞吐量就会受到影响。</p><p>也就是说，如果服务器创建大量的定时器，服务器处理命令请求的性能就会降低，</p><p>因此Redis目前并没有使用定时删除策略。</p><h3 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h3><p>惰性删除策略只会在获取键时才对键进行过期检查，不会在删除其它无关的过期键花费过多的CPU时间。</p><p>因此，惰性删除策略的优缺点如下所示：</p><ul><li>优点：对CPU时间非常友好</li><li>缺点：对内存非常不友好</li></ul><p>举个例子，如果数据库有很多的过期键，而这些过期键又恰好一直没有被访问到，那这些过期键就会一直占用着宝贵的内存资源，造成资源浪费。</p><h3 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h3><p>定期删除策略是定时删除策略和惰性删除策略的一种整合折中方案。</p><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，同时，通过定期删除过期键，也有效地减少了因为过期键而带来的内存浪费。</p><h3 id="Redis使用的过期键删除策略"><a href="#Redis使用的过期键删除策略" class="headerlink" title="Redis使用的过期键删除策略"></a>Redis使用的过期键删除策略</h3><p>Redis服务器使用的是惰性删除策略和定期删除策略。通过这两种删除策略的配合使用，服务器可以很好的在合理使用CPU时间和避免内存空间浪费之间取得平衡。</p><p><strong>惰性删除策略的实现：</strong></p><p>过期键的删除策略由expireIfNeeded函数实现，所有读写数据库的Redis命令都会在执行钱调用该函数进行检查。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    </span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                               dbSyncDelete(db,key);</span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，如果输入键已经过期，那么expireIfNeed函数将输入键从数据库删除。如果输入键没有过期，则不会做其他动作。所以，每个命令的实现函数都必须能同时处理键存在和不存在两种情况。</p><p><img src="https://pic.imgdb.cn/item/631ae47216f2c2beb17ac3f2.png"></p><p><strong>定期删除策略的实现：</strong></p><p>​Redis会将每个设置了过期时间的key放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的key。Redis默认每秒进行10次过期扫描（100ms一次，可以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数），但这个扫描并不会扫描过期字典中所有的key，而是通过一种贪心策略来随机筛选删除key，步骤如下：</p><ol><li>从过期字典中随机选出20个key；</li><li>删除这20个key中已经过期的key；</li><li>如果过期的key的比例超过了1&#x2F;4，那就重复从步骤1开始执行。</li></ol><p>之所以采用这种扫描策略，还是为了性能考虑。假如过期字典中有数百万个key，每隔100ms就扫描一次这数百万个key，会给CPU造成很大的负荷，所以，就选择了这种随机筛选部分key，然后按照过期比例来判断是否需要重复执行筛选过期的动作。</p><p>​该策略由activeExpireCycle函数实现，每当服务器周期性的操作serverCron函数执行的时候，activeExpireCycle函数就会被调用，在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随你检查一部分的过期时间，并删除其中的过期键。具体代码在redis6在expire.c中，redis3在redis.c中。</p><p><strong>实现原理（activeExpireCycle函数）</strong></p><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内， 分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时 间，并删除其中的过期键。<br>整个过程可以用伪代码描述如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#默认每次检查的数据库数量</span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">#默认每个数据库检查的键数量</span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">#全局变量，记录检查进度</span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">def activeExpireCycle():</span><br><span class="line">    # 初始化要检查的数据库数量</span><br><span class="line">    # 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 要小</span><br><span class="line">    # 那么以服务器的数据库数量为准</span><br><span class="line">    <span class="keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line"># 遍历各个数据库</span><br><span class="line"><span class="keyword">for</span> i in range(db_numbers):</span><br><span class="line">    # 如果current_db 的值等于服务器的数据库数量</span><br><span class="line">    # 这表示检查程序已经遍历了服务器的所有数据库一次</span><br><span class="line">    # 将current_db 重置为<span class="number">0</span> ，开始新的一轮遍历</span><br><span class="line">    <span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">        current_db = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">    # 获取当前要处理的数据库</span><br><span class="line">    redisDb = server.db[current_db]</span><br><span class="line"></span><br><span class="line">    # 将数据库索引增<span class="number">1</span> ，指向下一个要处理的数据库</span><br><span class="line">    current_db += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    # 检查数据库键</span><br><span class="line">    <span class="keyword">for</span> j in range(DEFAULT_KEY_NUMBERS):</span><br><span class="line">        # 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span><br><span class="line">        <span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            #随机获取一个带有过期时间的键</span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line"></span><br><span class="line">            # 检查键是否过期，如果过期就删除它</span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">            # 已达到时间上限，停止处理</span><br><span class="line">            <span class="keyword">if</span> reach_time_limit(): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>activeExpireCycle函数的工作模式总结</strong>：</p><p>函数每次运行时，都会从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键全局变量current_db会记录当前activeExpireCycle函数检查的进度，即当前查询到的数据库，并在下一次 activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前 activeExpireCycle函数在遍历完1号数据库完成过期键的删除后，那么下次activeExpireCycle函数执行时，将从2号数据库开始查找并删除过期键随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</p><h3 id="关于AOF、RDB对过期键的处理"><a href="#关于AOF、RDB对过期键的处理" class="headerlink" title="关于AOF、RDB对过期键的处理"></a>关于AOF、RDB对过期键的处理</h3><p><strong>1.生成RDB文件</strong></p><p>  在执行SAVE或者BGSAVE命令创建一个新的RDB文件的时候，程序会对数据库中的过期键进行检查，过期的键不会被保存到新创建的RDB文件中。<br><strong>2.载入RDB文件</strong></p><p>  载入的时候分为两种情况<br>  (1)服务器以主服务器运行。<br>  当服务器以主服务器运行的时候，会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期的键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。<br>  (2)服务器以从服务器运行。<br>  当服务器以从服务器运行的时候，会将文件中保存的所有键进行保存，不论是否过期。但是由于主从服务器进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键载入RDB文件的从高服务器也不会造成影响<br><strong>3.AOF文件的写入</strong></p><p>  当数据库中某个键已经过期，但是它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令进行显示的删除。<br><strong>4.AOF文件的重写：</strong></p><p>  重写的时候程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中这里有一个有意思的东西，当服务器运行在主从复制模式下的时候，从服务器的过期键删除动作是由主服务器控制的。主服务器在删除一个过期键后，会显示的向所有从服务器发送一个DEL命令，命令从服务器删除这个键；从服务器在执行客户端发送的命令的时候，即使遇到过期的键也不会将过期的键进行删除，是继续像处理未过期的键一样来处理过期键；从服务器只有在接到主服务器发送来的DEL命令的时候才会删除过期键。</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>通过上述对redis的对过期键的删除策略的介绍，可以发现无论是惰性删除策略还是定时删除策略，都会存在有过期键没有及时删除的情况，而在某些时刻有大量的键过期，同时又有大量的键要添加时，redis的内存空间就可能把占满，这时候如果想存入新的键，就必须引入内存淘汰策略，先淘汰掉一部分键，再把新的键存入。</p><h4 id="LRU和LFU算法"><a href="#LRU和LFU算法" class="headerlink" title="LRU和LFU算法"></a>LRU和LFU算法</h4><p>在介绍redis的内存淘汰策略之前，需要先了解一下两种淘汰最大空闲时间的策略LRU和LFU。</p><ul><li><strong>LRU算法</strong></li></ul><p>LRU（Least Recently Used），表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。标准的LRU算法一般会使用hash表和双向链表去降低查找和删除元素的时间复杂度，hash表可以赋予链表快速查找到某个key是否存在链表中，同时可以快速删除、添加节点。双向链表的查找时间复杂度是O(n)，删除和插入是O(1)，但是借助HashMap结构，可以使得查找的时间复杂度变成O(1)，Hash表用来查询在链表中的数据位置，链表负责数据的插入，当新数据插入到链表头部时有两种情况。</p><p>1）链表满了，把链表尾部的数据丢弃掉，新加入的缓存直接加入到链表头中。</p><p>2）当链表中的某个缓存被命中时，直接把数据移到链表头部，原本在头节点的缓存就向链表尾部移动。</p><p>这样，经过多次Cache操作之后，最近被命中的缓存，都会存在链表头部的方向，没有命中的，都会在链表尾部方向，当需要替换内容时，由于链表尾部是最少被命中的，我们只需要淘汰链表尾部的数据即可。</p><ul><li><strong>LFU算法</strong></li></ul><p>LFU（Least Frequently Used），表示最近最少使用，它和key的使用次数有关，其思想是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰，反之则保留。LFU的原理是使用计数器来对key进行排序，每次key被访问时，计数器会增大，当计数器越大，意味着当前key的访问越频繁，也就是意味着它是热点数据。 它很好的解决了LRU算法的缺陷：一个很久没有被访问的key，偶尔被访问一次，导致被误认为是热点数据的问题。LFU维护了两个链表，横向组成的链表用来存储访问频率，每个访问频率的节点下存储另外一个具有相同访问频率的缓存数据。具体的工作原理是：</p><p>1）当添加元素时，找到相同访问频次的节点，然后添加到该节点的数据链表的头部。如果该数据链表满了，则移除链表尾部的节点<br>2）当获取元素或者修改元素时，都会增加对应key的访问频次，并把当前节点移动到下一个频次节点</p><p>添加元素时，访问频率默认为1，随着访问次数的增加，频率不断递增。而当前被访问的元素也会随着频率增加进行移动。</p><p><strong>Redis中并不是完全采用LRU和LFU算法，内部做了一些优化，这里只是对这两种算法做一个简单的介绍，详细讲解请参考其他文章。</strong></p><h4 id="Redis中8种内存淘汰策略"><a href="#Redis中8种内存淘汰策略" class="headerlink" title="Redis中8种内存淘汰策略"></a>Redis中8种内存淘汰策略</h4><p><strong>1.noeviction</strong></p><p>不进行数据淘汰，也是Redis的默认配置。这时，当缓存被写满时，再有写请求进来，Redis不再提供服务，直接返回错误。</p><p> <strong>2.volatile-random</strong></p><p>缓存满了之后，在设置了过期时间的键值对中进行随机删除。</p><p><strong>3.volatile-ttl</strong></p><p>缓存满了之后，会针对设置了过期时间的键值对中，根据过期时间的先后顺序进行删除,越早过期的越先被删除。</p><p><strong>4.volatile-lru</strong></p><p>缓存满了之后，针对设置了过期时间的键值对，采用LRU算法进行淘汰。</p><p><strong>5.volatile-lfu</strong></p><p>缓存满了之后，针对设置了过期时间的键值对，采用LFU的算法进行淘汰。</p><p><strong>6.allkeys-random</strong></p><p>缓存满了之后，从所有键值对中随机选择并删除数据。</p><p><strong>7.allkeys-lru</strong></p><p>缓存写满之后，使用LRU算法在所有的数据中进行筛选删除。</p><p><strong>8.allkeys-lfu</strong></p><p>缓存满了之后，使用LRU算法在所有的数据中进行筛选删除。</p><p>在日常使用过程中，主要根据你的数据要求来配置相应的策略，这里我给你三点建议。</p><ul><li>我们优先使用allkeys-lru 策略。这样，我们就可以借助LRU算法去淘汰那些不常用的数据，把最近最常用的放在缓存中，从而提高应用的性能。如果你的数据有明显的冷热区分，建议你使用allkeys-lru策略。</li><li>如果你的数据的访问频率相差不大，也没有冷热之分，直接使用allkeys-random 策略，随机选择淘汰的数据就行。</li><li>如果你的数据有置顶要求，比如置顶新闻等。那么我们就选择volatile-lru策略，同时不给置顶数据设置过期时间，这样一来，置顶的数据永远不会被删除，而其他设置了过期时间的数据，会更加LRU算法进行淘汰</li></ul><p><strong>注意</strong>：基于LFU算法的策略是Redis4.0版本之后增加的，如要使用，请注意自己的redis版本。</p><h4 id="如何获取及设置内存淘汰策略"><a href="#如何获取及设置内存淘汰策略" class="headerlink" title="如何获取及设置内存淘汰策略"></a>如何获取及设置内存淘汰策略</h4><p>1、获取当前内存淘汰策略：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory-policy</span><br></pre></td></tr></table></figure><p>可以看到当前使用的默认的noeviction策略</p><p>2、获取Redis能使用的最大内存大小</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory</span><br></pre></td></tr></table></figure><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位机器限制最大 3 GB 的可用内存</p><p>3、设置淘汰策略</p><p>通过配置文件设置淘汰策略（修改redis.conf文件）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>通过命令修改淘汰策略：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>4、设置Redis最大占用内存大小</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#设置Redis最大占用内存大小为<span class="number">100</span>M</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config set maxmemory <span class="number">100</span>mb</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的过期键的删除策略&quot;&gt;&lt;a href=&quot;#Redis的过期键的删除策略&quot; class=&quot;headerlink&quot; title=&quot;Redis的过期键的删除策略&quot;&gt;&lt;/a&gt;Redis的过期键的删除策略&lt;/h2&gt;&lt;p&gt;Redis是一种基于内存的高性能键值对(ke</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://wangchengji.github.io/fwzssd/bae4ff13.html"/>
    <id>https://wangchengji.github.io/fwzssd/bae4ff13.html</id>
    <published>2022-09-01T03:50:06.000Z</published>
    <updated>2022-09-06T01:46:51.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>简介：Redis(REmote DIctionary Server)是用c语言开发的一个开源的高性能键值对(key-value)数据库，Redis 是一个开源（BSD许可）的，<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。是一个NoSQL数据库，NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a><strong>特征：</strong></h4><ul><li><p>高性能。</p><p>内存存储，不走磁盘<code>IO</code>，在大数据量下也可以高性能运行。</p><p>官方提供测试数据，50个并发执行100000个请求,读110000 次&#x2F;s,写81000次&#x2F;s</p></li><li><p>数据结构丰富</p><p>支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及<code>zset</code>(sorted set：有序集合)。</p></li><li><p>原子性</p><p>核心读写部分是单线程的，排队执行，对应的操作便具有了原子性，避免了多线程操作带来的复杂性和不安全因素。Redis6.0开始，网络传输支持多线程。</p></li><li><p>易拓展。</p><p>关系型数据库中记录、表关系复杂，扩容难度高；<code>NoSQL</code>中数据无关系，<code>Redis</code>3.0开始支持集群，扩容简单。</p></li><li><p>高可用。（高并发、高可用、高性能）</p><p><code>Redis</code>3.0开始支持集群，可以多主多从，当某个节点发生异常时，可以由其他对应节点顶替，保持整个集群的高可用。</p></li><li><p>可持久化（异地灾备）</p><p>支持把数据持久化存储到磁盘中，以便下次启动或遇到故障时，从磁盘加载恢复数据。</p></li></ul><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p><strong>支持的数据类型</strong>（值支持的类型如下，键只有<code>String</code>）</p><ul><li><table><thead><tr><th>支持类型</th><th>表示形式</th></tr></thead><tbody><tr><td>字符串类型</td><td><code>string</code>(普通字符串，常用)</td></tr><tr><td>列表类型</td><td><code>list</code>(按照插入顺序排序，可以有重复元素，可做消息队列)</td></tr><tr><td>Hash类型</td><td><code>hash</code>(适合存储对象)</td></tr><tr><td>集合类型</td><td><code>set</code>(无序集合，没有重复元素)</td></tr><tr><td>有序集合类型</td><td><code>zset/sorted_set</code>(集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素)</td></tr></tbody></table></li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><span style="color:blue"><strong>应用场景：</strong></span></h4><ul><li><span style="color:red">缓存</span>。查询频率较高，长久保存，但又不经常变化的数据。</li><li><span style="color:red">即时信息</span>。临时性的，经常变化的数据。</li><li><code>Session</code>共享。解决分布式系统中<code>session</code>共享的问题。</li><li>其他。诸如：时效性信息、消息队列（MQ MessageQueue）等</li></ul><h3 id="安装配置启动："><a href="#安装配置启动：" class="headerlink" title="安装配置启动："></a>安装配置启动：</h3><ul><li><p><strong>windows下安装运行：</strong></p><p> 下载安装：到GitHub上 <a href="https://github.com/ServiceStack/redis-windows">ServiceStack&#x2F;redis-windows：Vagrant redis configuration 和 MS Open Tech redis port of windows 的二进制版本 (github.com)</a> 下载安装包，解压即完成安装；</p><p>运行：解压目录两个文件分别启动服务端（redis-cli.exe）和客户端（redis-cli.exe），双击启动(默认端口(6379)、默认配置启动)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果双击客户端cmd窗口一闪而过，可以尝试在redis-cli.exe所在目录下打开cmd窗口输入</span></span><br><span class="line">redis-server.exe redis.windows.conf </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server.exe --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server.exe redis.conf --port 6380</span><br></pre></td></tr></table></figure><p>客户端连接服务端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接本机上服务端默认端口</span></span><br><span class="line">redis-cli.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -h 192.168.115.130 -p 6380</span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>linx中下载安装运行：</strong></p><p>下载：登录<code>redis.cn</code>（ <a href="http://download.redis.io/releases/">Index of &#x2F;releases&#x2F; (redis.io)</a> ）下载自己需要下载指定版本的安装包；</p><p>安装和启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.准备工作1：安装wget</span></span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.准备工作2：安装gcc编译环境</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.在/usr/loca目录（用户软件安装目录）创建redis文件夹（包括data文件夹、log文件夹）</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.上传/下载redis安装包到centos，下面两个步骤（1.1和1.2）任选其一即可</span></span><br><span class="line"><span class="comment"># 1.1 上传离线安装包，上传redis安装包到centos7</span></span><br><span class="line"><span class="comment"># crt工具 Alt + p 打开sftp窗口，通过put命令上传到登录用户的home目录</span></span><br><span class="line">put redis-linux-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剪切压缩包到安装目录</span></span><br><span class="line"><span class="built_in">mv</span> /root/redis-linux-5.0.5.tar.gz /usr/local/redis/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 在线下载安装包（需要安装好了wget）</span></span><br><span class="line">wget -P /usr/local/redis http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入redis目录</span></span><br><span class="line"><span class="built_in">cd</span>  /usr/local/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解压到当前目录</span></span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进入解压目录，执行编译</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 进入src目录，可以看到服务端和客户端的启动程序</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server</span><br><span class="line">./redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 6.新建数据目录和日志目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 在任意位置位置启动Redis-server</span></span><br><span class="line"><span class="comment"># 打开linux配置path的文件,</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#在文件末尾添加下面两行,其中REDIS_HOME的值是redis安装的根目录</span></span><br><span class="line"><span class="built_in">export</span> REDIS_HOME=/usr/local/redis/redis-5.0.5</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$REDIS_HOME</span>/src:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p> 指定端口&#x2F;配置文件启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认端口启动服务端</span></span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server ../redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接非默认端口的服务端</span></span><br><span class="line">redis-cli -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用密码连接</span></span><br><span class="line">redis-cli -p 6380 -a 123456</span><br><span class="line"><span class="comment"># 或者连接后使用指定的命令认证</span></span><br><span class="line">auth 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体上和Windows一致</span></span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用docker快速部署redis</strong></p><p> 进入dockerHub官网，查询redis镜像<a href="https://hub.docker.com/_/redis%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9C%80%E6%B1%82%E6%8C%89%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E3%80%82">https://hub.docker.com/_/redis，根据自己的需求按官方文档下载镜像和配置容器。</a></p></li><li><p><strong>退出</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(`quit`、`<span class="built_in">exit</span>`、`ctrl + C` 、`Ctrl +D`)任选其一</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p><p> 宿主机连接虚拟机中的<code>redis</code>服务时，需要关闭保护模式或者绑定对应的<code>redis</code>服务所在设备的网卡。</p></li></ul><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><p>通过修改配置文件，可以让Redis服务运行在不同端口上、允许通过不同的网卡连接等。</p><ul><li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li><li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li></ul><h4 id="常见配置如下"><a href="#常见配置如下" class="headerlink" title="常见配置如下"></a>常见配置如下</h4><p><strong>1）设置Redis服务运行的端口</strong></p><p>port 6379</p><p><strong>2）设置Redis服务后台运行</strong></p><p>​将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p><p>​注意：Windows版的Redis不支持后台运行。</p><p><strong>3）</strong>设置<code>Redis</code>服务密码(如果是云主机建议设置密码)</p><p>​将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p><p><strong>4）</strong>设置允许客户端远程连接Redis服务</p><p>​远程连接redis注意防火墙设置</p><p>​Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p><p><strong>解释说明：</strong></p><blockquote><p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p><p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p><p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p><p>requirepass：设置Redis的连接密码</p><p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p></blockquote><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </li><li><strong>EXISTS</strong> key  检查给定 key 是否存在</li><li><strong>TYPE</strong> key  返回 key 所储存的值的类型</li><li><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</li></ul><h4 id="学习站"><a href="#学习站" class="headerlink" title="学习站"></a>学习站</h4><p>更多命令可以参考<a href="https://www.redis.net.cn/tutorial/3516.html">Redis中文网</a>或<a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程</a>。</p><h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jedis操作Redis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 执行具体的操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis.del(&quot;username&quot;);</span></span><br><span class="line"></span><br><span class="line">        jedis.hset(<span class="string">&quot;myhash&quot;</span>,<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hValue</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;addr&quot;</span>);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataredis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springdataredis_demo</span></span><br><span class="line">  <span class="comment">#Redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#操作的是0号数据库</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="comment">#Redis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">4</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><p>第四步：提供配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><p>第五步：提供测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作字符串类型数据"><a href="#操作字符串类型数据" class="headerlink" title="操作字符串类型数据"></a>操作字符串类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作String类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>,<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;city123&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，同时设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="number">10l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，如果存在则不执行任何操作</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;city1234&quot;</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    System.out.println(aBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作哈希类型数据"><a href="#操作哈希类型数据" class="headerlink" title="操作哈希类型数据"></a>操作哈希类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Hash类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有字段</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有值</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作列表类型数据"><a href="#操作列表类型数据" class="headerlink" title="操作列表类型数据"></a>操作列表类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作List类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    List&lt;String&gt; mylist = listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String value : mylist) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得列表长度 llen</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> size.intValue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">        <span class="comment">//出队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作集合类型数据"><a href="#操作集合类型数据" class="headerlink" title="操作集合类型数据"></a>操作集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Set类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作有序集合类型数据"><a href="#操作有序集合类型数据" class="headerlink" title="操作有序集合类型数据"></a>操作有序集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作ZSet类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">11.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">12.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">13.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改分数</span></span><br><span class="line">    zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用操作，针对不同的数据类型都可以操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取Redis中所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个key是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">itcast</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定key</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定key对应的value的数据类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;h3 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://wangchengji.github.io/fwzssd/c24675b4.html"/>
    <id>https://wangchengji.github.io/fwzssd/c24675b4.html</id>
    <published>2022-08-28T09:21:22.000Z</published>
    <updated>2022-08-28T10:23:10.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL相关知识"><a href="#MySQL相关知识" class="headerlink" title="MySQL相关知识"></a>MySQL相关知识</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="七大事务传播行为"><a href="#七大事务传播行为" class="headerlink" title="七大事务传播行为"></a>七大事务传播行为</h5><ol><li><p><strong>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</strong></p></li><li><p><strong>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</strong></p></li><li><p><strong>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</strong></p></li><li><p><strong>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</strong></p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</strong>(新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作；)</p></li><li><p><strong>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</strong></p></li><li><p><strong>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作</strong>。(嵌套事物是子事物套在父事物中执行，子事物是父事物的一部分，在进入子事物之前，父事物建立一个回滚点，叫save point，然后执行子事物，这个子事物的执行也算是父事物的一部分，然后子事物执行结束，父事物继续执行。重点就在于那个save point)</p></li></ol><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li><p><strong>读未提交（read Uncommited）:</strong> </p><p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项 目中基本不怎么用， 安全性太差；</p></li><li><p><strong>读已提交（read commited）:</strong> </p><p>这是大多数数据库默认的隔离级别，但是不是 MySQL 的默认隔离级别；这个隔离级别满足 了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等 问题；</p></li><li><p><strong>可重复读（Repeatable read）：</strong> </p><p> 这是 MySQL 的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取 到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简 单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当 36 用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通 过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题；</p></li><li><p><strong>可串行化（serializable）：</strong></p><p> 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之， 它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一 般为了提升程序的吞吐量不会采用这个；</p></li></ul><h5 id="脏读、不可重复读、可重复读、幻读"><a href="#脏读、不可重复读、可重复读、幻读" class="headerlink" title="脏读、不可重复读、可重复读、幻读"></a>脏读、不可重复读、可重复读、幻读</h5><ul><li><p><strong>dirty reads（脏读）：</strong>就是说事务A未提交的数据被事务B读走，如果事务A失败回滚，将导致B所读取的数据是错误的。</p></li><li><p><strong>non-repeatable reads（不可重复读）：</strong>，就是说事务A中两处读取数据，第一次读时是100，然后事务B把值改成了200，事务A再读一次，结果就发现值变了，造成A事务数据混乱。</p></li><li><p><strong>phantom read（幻读）：</strong>，和不可重复读相似，也是同一个事务中多次读不一致的问题。但是不可重复读的不一致是因为它所要取的数据集被改变了，而幻读所要读的数据不一致却不是他所要读的数据改变，而是它的条件数据集改变。比如：Select id where name&#x3D;”ppgogo*”，第一次读去了6个符合条件的id，第二次读时，由于事务B把第一个贴的名字由”dd”改成了“ppgogo9”，结果取出来7个数据。</p></li><li><p><strong>可重复读：</strong>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据。</p></li></ul><h5 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h5><ol><li><strong>原子性：</strong>即不可分割性，事务要么全部被执行，要么就全部不被执行；</li><li><strong>一致性：</strong>事务的执行使得数据库从一种正确状态转换成另一种正确状态 ；</li><li><strong>隔离性：</strong>在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务；</li><li><strong>持久性：</strong>事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障， 事务的处理结果也会得到保存。</li></ol><h4 id="MySQL解决可重复读和幻读的机制"><a href="#MySQL解决可重复读和幻读的机制" class="headerlink" title="MySQL解决可重复读和幻读的机制"></a>MySQL解决可重复读和幻读的机制</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL相关知识&quot;&gt;&lt;a href=&quot;#MySQL相关知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关知识&quot;&gt;&lt;/a&gt;MySQL相关知识&lt;/h3&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引</title>
    <link href="https://wangchengji.github.io/fwzssd/756c412e.html"/>
    <id>https://wangchengji.github.io/fwzssd/756c412e.html</id>
    <published>2022-08-27T01:15:22.000Z</published>
    <updated>2022-08-27T10:10:24.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL的索引的相关知识总结："><a href="#MySQL的索引的相关知识总结：" class="headerlink" title="MySQL的索引的相关知识总结："></a><strong>MySQL的索引的相关知识总结：</strong></h3><p>索引的概述：索引就是高效获取数据的数据结构</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul><li>优点<ol><li>提高数据检索的效率，降低数据库IO成本；</li><li>提高排序效率，通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li></ol></li><li>缺点：<ol><li>索引列会占用部分磁盘空间；</li><li>索引大大提高了查询的效率，同时降低了更新表的速度，关于对表的insert、update、delete操作，效率降低。</li></ol></li><li>总结：因为大多数表在使用的过程中，查询相关的SQL占到百分之95以上，而相较于CPU和内存来说，磁盘的占用带来的成本基本可用忽略，所以为了提高数据的检索效率而使用索引是非常有必要的。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><ul><li><p>B-tree特点：</p><ol><li><p>当节点中的索引key达到上限时中间的key会分裂出去；                         </p></li><li><p>所有的key都会出现在叶子节点，而所有的数据都存储在这些叶子节点上；</p></li><li><p>叶子节点形成一个单项链表。</p><p><img src="https://pic.imgdb.cn/item/6309dad716f2c2beb18d31d5.png"></p></li></ol></li><li><p>B+tree特点：</p><p>MySQL索引数据结构对经典的B-tree进行了优化。在原B-tree的基础上，增加一个指向相邻叶子节点的链表指针，形成了双向链表，就形成了带有顺序指针的B+tree，提高了区间访问的性能。</p><p><img src="https://pic.imgdb.cn/item/6309daf116f2c2beb18d407d.png"></p></li><li><p>Hash索引（Memory引擎）特点：</p><ol><li>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中，而如果存在hash冲突的键值（两个或者多个键值hash值相同），可以在对应槽位上增加链表来存储键值；</li><li>Hash索引只能用于对等比较（&#x3D;，in），不支持服务查询（between，&gt;,&lt;,…）;    </li><li>无法利用索引完成排序操作；  </li><li>查询效率高，通常情况只需要一次检索就可以了，效率通常要高于B+tree索引。</li></ol></li><li><p>为什么InnoDB存储引擎选择使用B+tree索引结构？</p><ol><li><p>相对于二叉树，B+tree的层级更加少，可以减少磁盘IO的次数，提高搜索效率；</p></li><li><p>相对于B-tree，因为在Mysql中一个节点代表一个分页，一个分页的大小是有限的（16kb），而B-tree中数据和索引存储在一个节点中，这样就会使得存储在一个节点上的key减少，造成树的高度增加，导致检索数据时磁盘IO次数增加，性能降低；</p></li><li><p>相对于Hash索引，B+tree支持的访问匹配和排序操作，叶子节点的双向链表结构便于范围搜索和排序。</p></li></ol></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键索引</td><td align="left">针对于表中主键创建的索引</td><td align="left">默认自动创建，且只能有一个</td><td align="left">primary</td></tr><tr><td align="left">唯一索引</td><td align="left">避免同一个表中某个数据列中存在相同数据</td><td align="left">可以有多个</td><td align="left">unique</td></tr><tr><td align="left">常规索引</td><td align="left">快速定位特定数据</td><td align="left">可以有多个</td><td align="left"></td></tr><tr><td align="left">全文索引</td><td align="left">全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td align="left">可以有多个</td><td align="left">fulltext</td></tr></tbody></table><p><strong>在InnDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</strong></p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（Clustered index）</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只能有一个</td></tr><tr><td>二级索引（Secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p><strong>聚集索引选取规则：</strong></p><ol><li>如果存在主键，主键索引就是聚集索引；</li><li>如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引；</li><li>如果表没有主键，或没有合适的唯一索引，则InnDB会自动生成一个rowid作为隐藏5的聚集索引。</li></ol><p><strong>简单点说</strong>聚集索引通过主键列上的值创建索引，把整行数据存储在索引所在叶子节点的下面，而二级索引就是通过索引列上的数据创建索引，而在叶子节点下存储的是该行数据的主键。</p><p><strong>InnoDB主键索引的B+tree高度为多高呢？？</strong></p><p>假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。则：</p><p>树高度为2：<br>n<em>8+(n+1)<em>6&#x3D;16</em>1024（一个节点指针比key多一个，一个节点大小为16k）n≈1170 1171</em>16&#x3D;18736<br> 树高度为3：                                                                                                                                           1171<em>1171</em>16&#x3D;21939856</p><h4 id="索引相关操作（SQL）"><a href="#索引相关操作（SQL）" class="headerlink" title="索引相关操作（SQL）"></a>索引相关操作（SQL）</h4><ol><li><p>查询索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure></li><li><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] [fulltext] index 索引名字（自己取） <span class="keyword">on</span>  表名（要添加索引的字段名，可以是多个字段，多字段代表创建联合索引）；</span><br></pre></td></tr></table></figure></li><li><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名。</span><br></pre></td></tr></table></figure></li></ol><h4 id="查询需要优化的SQL（运行慢的SQL）"><a href="#查询需要优化的SQL（运行慢的SQL）" class="headerlink" title="查询需要优化的SQL（运行慢的SQL）"></a>查询需要优化的SQL（运行慢的SQL）</h4><ul><li><p>查看当前数据库状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志：开启慢查询日志定位查询效率低的<code>sql</code>：</p><p>慢查询日志记录了所有执行时间超过指定参数（<code>long_query_time</code>,单位：秒，默认10秒）的所有<code>SQL</code>语句日志。<code>MySQL</code>的慢查询日志默认没有开启，需要在<code>MySQL</code>的配置文件（<code>/etc/my.cnf</code>）中做如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢日志查询</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被认定是慢查询，记录到查询日志</span><br><span class="line">log_query_time=2</span><br></pre></td></tr></table></figure><p>配置完成后，重启MySQL服务器测试，</p><p>查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code>。</p></li><li><p>profile详情查询sql执行时间：</p><p>查看数据库是否支持profile：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>开启profile查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>执行想判断的SQL，然后通过下面指令查询SQL的执行时间：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看每一条<span class="keyword">sql</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles；</span><br><span class="line"></span><br><span class="line">#查看指定query id 的<span class="keyword">sql</span>语句各阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">sql</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li><li><p>explain执行计划:</p><p>语法：explain  + select 语句;</p><p>explain中各字段含义：</p><ol><li>id：select查询的序列号，表示查询中执行select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。连表查询中一般两张表的id都相同且按from后表的顺序查询；如果有子查询子查询中的select的id会更大，子查询先执行。</li><li>select_type：表示select的类型，常见的取值有simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select&#x2F;where之后包含了子查询）等。</li><li>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。<ul><li>NULL：业务代码中一般不太可能达到，不查询表的select查询：select ’A’；</li><li>system：一般出现在查询系统表时;</li><li>const：按主键索引查询;</li><li>ref：一般是二级索引查询;</li><li>range：范围匹配查询;</li><li>index：索引全表扫描;</li><li>all：全表扫描.</li></ul></li><li>possible_key：可能应用在这张表上的索引。</li><li>key：实际用到的索引.</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li>rows：MYSQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</li><li>filtered：表示返回结果的行数占读取行数的百分比，这个值越大越好。</li><li>Extra：其他信息。</li></ol><h4 id="索引使用相关规则"><a href="#索引使用相关规则" class="headerlink" title="索引使用相关规则"></a>索引使用相关规则</h4><ol><li><p><strong>最左前缀法则：</strong>使用联合索引查询时，必须遵守最左前缀法则；即where条件在必须包含复合索引中最左边第一个字段的条件，否则索引不生效，按照索引中字段的顺序，如果条件中不存在中间某个字段的条件，则后面字段的索引也不会生效。（注：where条件中只需要包含相关字段添加即可，条件顺序的并不影响索引的使用）联合查询中使用了范围查询（&gt;,&lt;）：范围查询右侧的列索引生效，在业务允许的条件下可以使用&lt;&#x3D;和&gt;&#x3D;索引就又可以使用了。</p></li><li><p><strong>不能在条件上加函数运算，否则索引将失效。</strong></p></li><li><p><strong>字符串不加引号，会引发隐式类型转换，导致索引失效。</strong></p></li><li><p><strong>模糊查询like：%加前面索引失效，%加后面索引还是生效的。%xx(失效)、xx%（生效）。</strong></p></li><li><p><strong>or连接条件：如果or两侧列都有索引则通过两侧索引查询，如果存在一侧没有索引则来一侧存在索引的列索引会失效。</strong></p></li><li><p><strong>数据评估影响（mysql实现）：如果查询的数据占了表中的大头，mysql判断使用全表扫描效率更高，mysql就会放弃使用索引，进行全表扫描。</strong></p></li><li><p><strong>SQL提示：是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</strong></p><ul><li><p>use index（索引名)   </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ignore index（索引名）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 忽略使用该索引，让这次查询不使用该索引。</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>force index（索引名） </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制此次查询使用该索引</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>覆盖索引</strong>：</p></li></ol><ul><li><p>什么是回表查询？</p><p>场景：存在一张表user有3个字段主键id、name、age；列name存在二级索引，当我们使用select * from user where name &#x3D; ‘zs’,此时就存在回表查询。</p><p>解释：上述sql会根据name字段的二级索引进行查询，但是name字段上的二级索引只保存了name上的值和id，而我们使用select * 查询全字段信息，而age字段的信息是无法通过name字段的二级索引查询到的，这时候就需要进行回表查询，通过二级索引查询到的id再通过主键id的聚集索引查询到这条数据的所有信息。</p></li><li><p>覆盖索引避免回表查询：</p><p>可以使用联合索引，把经常需要查的字段信息合并到一个联合索引中，在select 后只添加这些需要查询的字段，即可通过二级索引就获得需要的字段信息，避免回表查询。</p></li></ul><ol start="9"><li><strong>前缀索引</strong>：</li></ol><ul><li><p>应用场景：大文本或者数据列建立索引时只截取文本前指定长度的数据当做索引。</p></li><li><p>索引长度指定规则：</p><p>当字段类型为字符串（varchar，text等）时,有时候需要索引很长的字符串，这样会让索引变得很大，因为节点的大小有限，单个索引变大，单个节点内可以存储的索引数量就会减少，树的高度就会增加，查询时，浪费大量的磁盘IO，影响查询效率。此时可以用字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure></li><li><p>前缀长度选择：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引过多，维护索引结构的代价就会过大，会影响增删改的效率。</li><li>如果索引列不能存储null值，请在创建表的时候使用not null约束它，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有利于查询。</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;a href=&quot;#MySQL的索引的相关知识总结：&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;/a&gt;&lt;strong&gt;MySQL的索引的相关知识总结：&lt;/strong&gt;&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Development Tool</title>
    <link href="https://wangchengji.github.io/fwzssd/60588ca5.html"/>
    <id>https://wangchengji.github.io/fwzssd/60588ca5.html</id>
    <published>2022-08-26T07:21:03.000Z</published>
    <updated>2022-08-27T10:12:56.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发过程中相关工具的下载："><a href="#java开发过程中相关工具的下载：" class="headerlink" title="java开发过程中相关工具的下载："></a>java开发过程中相关工具的下载：</h2><h4 id="JDK的下载和环境配置："><a href="#JDK的下载和环境配置：" class="headerlink" title="JDK的下载和环境配置："></a>JDK的下载和环境配置：</h4><ul><li><p><input disabled="" type="checkbox"> jdk的下载（建议下载1.8和11的版本）：</p><ol><li><p>打开浏览器输入网址 <a href="https://www.oracle.com/index.html%EF%BC%8C%E8%BF%9B%E5%85%A5[Oracle%E5%AE%98%E7%BD%91](https://www.oracle.com/index.html)">https://www.oracle.com/index.html，进入[Oracle官网](https://www.oracle.com/index.html)</a> ，在<code>Producet</code>下找到<code>Java</code>根据自己的操作系统选择对应的版本进行下载；</p></li><li><p>jdk安装：</p><p> 2.1 下载完JDK到本地后，找到该文件，双击运行JDK安装程序 ，进入JDK安装界面，点击下一步； </p><p>2.2 可以直接默认目录，点击下一步。也可以自定义路径，先创建一个文件夹名为Java，再在该文件夹下创建一个文件夹为JDK安装目录，同时创建一个文件夹为JRE安装目录 ；</p><p> 2.3然后回到JDK安装界面，更改安装路径，为上述所创建的JDK路径，点击下一步（<strong>这里由于第一项开发工具中已经自带了 JRE，则第三项的公共 JRE 可以取消独立安装，上述创建的 JRE 文件夹也不需要了</strong>）。无其他需求，取消安装JRE即可；</p><p>2.4等待一会，会进入 JRE 的安装界面，同样的更改路径，为上述所创建的 JRE 路径，更改完之后点击下一步（<strong>在上一步取消公共 JRE 安装的则不会出现下面的界面，直接到 2.5 安装完成</strong>）； </p><p>2.5至此JDK已经安装完毕，点击关闭 ；</p><p>2.6测试是否安装成功：可以进入安装好的jdk中的bin目录下打开cmd窗口运行<code>java -version</code>出现信息即可。</p></li><li><p>windows版本的jdk百度网盘下载：链接: <a href="https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8">https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8</a> 提取码: k8d8 复制这段内容后打开百度网盘手机App，操作更方便哦</p></li></ol></li><li><p><input disabled="" type="checkbox"> jdk运行环境的配置（为了在任何终端都可以使用jdk）：</p><p>1.windows操作系统中找到系统的高级设置；</p></li></ul><p>​       2.找到环境变量</p><p>​       3.点击新增；</p><p>​       4.新增变量<code>JAVA_HOME</code>，变量值是安装的jdk的根目录（包含bin目录的那个目录）；</p><p>​       5.找到变量<code>Path</code>新增变量 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code> ；</p><p>​       6.测试，在任意终端输入<code>javac</code>得到java配置信息即表示配置成功。</p><h4 id="idea下载和破解："><a href="#idea下载和破解：" class="headerlink" title="idea下载和破解："></a>idea下载和破解：</h4><ul><li><p><input disabled="" type="checkbox"> idea的安装包的下载（建议不要下载过新的版本，使用20~21版本即可方便破解）：</p><ol><li><p>打开浏览器输入<a href="https://www.jetbrains.com/%EF%BC%8C%E8%BF%9B%E5%85%A5">https://www.jetbrains.com/，进入</a> <a href="https://www.jetbrains.com/">Jetbrains官网</a>，点击 Developer Tools，再点击 Intellij IDEA ；</p></li><li><p>点击中间的download，进入IDEA下载界面 ；</p></li><li><p>选择左边的Ultimate版本进行下载安装。Ultimate版本为旗舰版，需要付费，包括完整的功能。Community 版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，后续进行激活 ；</p></li></ol></li><li><p><input disabled="" type="checkbox"> ​     idea安装：</p><ol><li><p>下载完后在本地找到该文件，双击运行 idea 安装程序 ；</p></li><li><p>点击 Next ；</p></li><li><p>选择安装路径，Next ；</p></li></ol></li></ul><p>​          4.按需求选择，点击 Next ,版本不同有不同的选择，之前版本可能需要选择电脑的版本；</p><p>​          5.默认，不用改，直接点 Install，安装 ；</p><p>​         6.安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA 。</p><ul><li><p><input disabled="" type="checkbox"> 破解idea：</p><p>破解idea主要有两种破解方式，永久版破解到2099年，参考 <a href="http://www.itmind.net/13082.html">IntelliJ IDEA 2021.3.3破解教程（亲测有效，激活至2099年） (itmind.net)</a> ；刷新试用时间版，参考 <a href="http://www.itmind.net/12400.html">2022年IntelliJ IDEA最新破解教程，无限重置试用期 (亲测有效) (图文教程) (itmind.net)</a> ；刷新试用时间的破解方式比较容易操作。</p><p>（内附2021版本idea下载破解商品链接: <a href="https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA">https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA</a> 提取码: 865s 复制这段内容后打开百度网盘手机App，操作更方便哦）</p></li></ul><h4 id="maven的下载和配置："><a href="#maven的下载和配置：" class="headerlink" title="maven的下载和配置："></a>maven的下载和配置：</h4><p>1.官网 <a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a> 下载压缩包；</p><p>2.放到安装目录直接解压即可；</p><p>3.国内访问中央仓库过慢，在config包的setting.xml中配置阿里云的镜像地址，加速依赖下载；</p><p>在<mirrors>标签中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.环境配置：和jdk一样，在系统的环境变量中配置maven的变量；</p><p>变量名：MAVEN_HOME</p><p>变量值：maven的根目录</p><p>5.在<code>path</code>变量中新增<code>%MAVEN_HOME%\bin</code>变量</p><h4 id="git的下载："><a href="#git的下载：" class="headerlink" title="git的下载："></a>git的下载：</h4><p>1.进入官网 <a href="https://git-scm.com/">吉特 (git-scm.com)</a> 下载安装包；</p><p>2.双击安装包安装，一直点击next,直到出现install,点击install,然后点击finish，安装完成。 </p><p>3.安装完成后，桌面右键出现Git GUI、Git bash选项，说明已安装： </p><h4 id="数据库图形化软件："><a href="#数据库图形化软件：" class="headerlink" title="数据库图形化软件："></a>数据库图形化软件：</h4><p>1.下载破解Navicat： <a href="http://www.itmind.net/13042.html">Navicat Premium 15 破解激活教程,永久有效(亲测可用) (itmind.net)</a> </p><p>或者 <a href="https://www.downkuai.com/soft/150597.html">Navicat 16破解版(附激活秘钥)下载-Navicat premium 16破解版下载 v16.0.4附安装破解教程-当快软件园 (downkuai.com)</a> </p><h4 id="Redis图形化软件："><a href="#Redis图形化软件：" class="headerlink" title="Redis图形化软件："></a>Redis图形化软件：</h4><p>1.RedisDesktopManager安装包链接: <a href="https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law">https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law</a> 提取码: 8s8d 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>2.QuickRedis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;a href=&quot;#java开发过程中相关工具的下载：&quot; class=&quot;headerlink&quot; title=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;/a&gt;java开发过程中相关工具的下载：&lt;/h2&gt;&lt;h4 id=&quot;JDK的下</summary>
      
    
    
    
    
    <category term="Java" scheme="https://wangchengji.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangchengji.github.io/fwzssd/4a17b156.html"/>
    <id>https://wangchengji.github.io/fwzssd/4a17b156.html</id>
    <published>2022-08-25T09:37:53.819Z</published>
    <updated>2022-08-27T10:11:56.740Z</updated>
    
    <content type="html"><![CDATA[<p>快速发布新文章</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到线上"><a href="#发布到线上" class="headerlink" title="发布到线上"></a>发布到线上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速发布新文章&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;新增文章&quot;&gt;&lt;a href=&quot;#新增文章&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://wangchengji.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
