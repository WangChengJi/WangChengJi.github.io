<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凉人夢</title>
  
  <subtitle>十里八乡有名的俊后生</subtitle>
  <link href="https://wangchengji.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangchengji.github.io/"/>
  <updated>2022-09-16T07:38:08.701Z</updated>
  <id>https://wangchengji.github.io/</id>
  
  <author>
    <name>凉人夢</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentinel</title>
    <link href="https://wangchengji.github.io/fwzssd/1408c19.html"/>
    <id>https://wangchengji.github.io/fwzssd/1408c19.html</id>
    <published>2022-09-16T06:34:17.000Z</published>
    <updated>2022-09-16T07:38:08.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>简介:Sentinel 是面向分布式服务架构的高可用流量防护组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Sentinel&quot;&gt;&lt;a href=&quot;#Sentinel&quot; class=&quot;headerlink&quot; title=&quot;Sentinel&quot;&gt;&lt;/a&gt;Sentinel&lt;/h1&gt;&lt;p&gt;简介:Sentinel 是面向分布式服务架构的高可用流量防护组件，主要以流量为切入点，从限流</summary>
      
    
    
    
    
    <category term="Sentinel" scheme="https://wangchengji.github.io/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化机制</title>
    <link href="https://wangchengji.github.io/fwzssd/e5adb42e.html"/>
    <id>https://wangchengji.github.io/fwzssd/e5adb42e.html</id>
    <published>2022-09-12T03:31:11.000Z</published>
    <updated>2022-09-12T12:49:09.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h1><h2 id="1-Redis的持久化"><a href="#1-Redis的持久化" class="headerlink" title="1.Redis的持久化"></a>1.Redis的持久化</h2><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1.RDB持久化"></a>1.1.RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1.执行时机"></a>1.1.1.执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>进入redis客户端输入<strong>save</strong>，会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>同样在redis客户端输入<strong>bgsave</strong>命令可以异步执行RDB，这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2.RDB原理"></a>1.1.2.RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://pic.imgdb.cn/item/631ee01f16f2c2beb1392b8d.png"></p><h3 id="1-1-3-小结"><a href="#1-1-3-小结" class="headerlink" title="1.1.3.小结"></a>1.1.3.小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="1-2-AOF持久化"><a href="#1-2-AOF持久化" class="headerlink" title="1.2.AOF持久化"></a>1.2.AOF持久化</h2><h3 id="1-2-1-AOF原理"><a href="#1-2-1-AOF原理" class="headerlink" title="1.2.1.AOF原理"></a>1.2.1.AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><h3 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2.AOF配置"></a>1.2.2.AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略对比：</p><table><thead><tr><th align="center">配置项</th><th align="center">刷盘时间</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">Always</td><td align="center">同步刷盘</td><td align="center">可靠性高，几乎不丢失数据</td><td align="center">性能影响大</td></tr><tr><td align="center">everysec</td><td align="center">每秒刷盘</td><td align="center">性能适中</td><td align="center">最多丢失1秒数据</td></tr><tr><td align="center">no</td><td align="center">操作系统控制</td><td align="center">性能最好</td><td align="center">可靠性差，可能丢失大量数据</td></tr></tbody></table><h3 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3.AOF文件重写"></a>1.2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://pic.imgdb.cn/item/631ef0aa16f2c2beb14ad9b4.png"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h2 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3.RDB与AOF对比"></a>1.3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th align="center"></th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">持久化方式</td><td align="center">定时对整个内存做快照</td><td align="center">记录每一次执行的命令</td></tr><tr><td align="center">数据完整性</td><td align="center">不完整，两次备份之间会丢失</td><td align="center">相对完整，取决于刷盘策略</td></tr><tr><td align="center">文件大小</td><td align="center">会有压缩，文件体积小</td><td align="center">记录命令，文件体积很大</td></tr><tr><td align="center">宕机恢复速度</td><td align="center">很快</td><td align="center">慢</td></tr><tr><td align="center">数据恢复优先级</td><td align="center">低，因为数据完整性不如AOF</td><td align="center">高，因为数据完整性高</td></tr><tr><td align="center">系统资源占用</td><td align="center">高，大量CPU和内存消耗</td><td align="center">低,主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td align="center">使用场景</td><td align="center">可以容忍数分钟的数据丢失，追求更加快的启动速度</td><td align="center">对数据安全性要求较高</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis的持久化机制&quot;&gt;&lt;a href=&quot;#Redis的持久化机制&quot; class=&quot;headerlink&quot; title=&quot;Redis的持久化机制&quot;&gt;&lt;/a&gt;Redis的持久化机制&lt;/h1&gt;&lt;h2 id=&quot;1-Redis的持久化&quot;&gt;&lt;a href=&quot;#1-Redi</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的过期键删除策略</title>
    <link href="https://wangchengji.github.io/fwzssd/197f8.html"/>
    <id>https://wangchengji.github.io/fwzssd/197f8.html</id>
    <published>2022-09-09T07:25:35.000Z</published>
    <updated>2022-09-11T12:03:43.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是一种基于内存的高性能键值对(key-value)数据库，而内存的资源相对来说还是比较宝贵的，所以Redis需要定期删除数据库中过期的键值对。</p><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>Redis的删除策略有以下3种：</p><ul><li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li><strong>惰性删除</strong>：放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键。</li><li><strong>定期删除</strong>：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定。</li></ul><p>其中定时删除和定期删除为主动删除策略，惰性删除为被动删除策略。</p><h3 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h3><p>定时删除策略是使用定时器。定时删除策略可以保证过期键尽可能快地被删除，并释放过期键占用的内存。</p><p>因此，定时删除策略的优缺点如下所示：</p><ul><li>优点：对内存非常友好</li><li>缺点：对CPU时间非常不友好</li></ul><p>举个例子，如果有大量的命令请求等待服务器处理，并且服务器当前不缺少内存，如果服务器将大量的CPU时间用来删除过期键，那么服务器的响应时间和吞吐量就会受到影响。</p><p>也就是说，如果服务器创建大量的定时器，服务器处理命令请求的性能就会降低，</p><p>因此Redis目前并没有使用定时删除策略。</p><h3 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h3><p>惰性删除策略只会在获取键时才对键进行过期检查，不会在删除其它无关的过期键花费过多的CPU时间。</p><p>因此，惰性删除策略的优缺点如下所示：</p><ul><li>优点：对CPU时间非常友好</li><li>缺点：对内存非常不友好</li></ul><p>举个例子，如果数据库有很多的过期键，而这些过期键又恰好一直没有被访问到，那这些过期键就会一直占用着宝贵的内存资源，造成资源浪费。</p><h3 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h3><p>定期删除策略是定时删除策略和惰性删除策略的一种整合折中方案。</p><p>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，同时，通过定期删除过期键，也有效地减少了因为过期键而带来的内存浪费。</p><h3 id="Redis使用的过期键删除策略"><a href="#Redis使用的过期键删除策略" class="headerlink" title="Redis使用的过期键删除策略"></a>Redis使用的过期键删除策略</h3><p>Redis服务器使用的是惰性删除策略和定期删除策略。通过这两种删除策略的配合使用，服务器可以很好的在合理使用CPU时间和避免内存空间浪费之间取得平衡。</p><p><strong>惰性删除策略的实现：</strong></p><p>过期键的删除策略由expireIfNeeded函数实现，所有读写数据库的Redis命令都会在执行钱调用该函数进行检查。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    </span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                               dbSyncDelete(db,key);</span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，如果输入键已经过期，那么expireIfNeed函数将输入键从数据库删除。如果输入键没有过期，则不会做其他动作。所以，每个命令的实现函数都必须能同时处理键存在和不存在两种情况。</p><p><img src="https://pic.imgdb.cn/item/631ae47216f2c2beb17ac3f2.png"></p><p><strong>定期删除策略的实现：</strong></p><p>​Redis会将每个设置了过期时间的key放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的key。Redis默认每秒进行10次过期扫描（100ms一次，可以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数），但这个扫描并不会扫描过期字典中所有的key，而是通过一种贪心策略来随机筛选删除key，步骤如下：</p><ol><li>从过期字典中随机选出20个key；</li><li>删除这20个key中已经过期的key；</li><li>如果过期的key的比例超过了1&#x2F;4，那就重复从步骤1开始执行。</li></ol><p>之所以采用这种扫描策略，还是为了性能考虑。假如过期字典中有数百万个key，每隔100ms就扫描一次这数百万个key，会给CPU造成很大的负荷，所以，就选择了这种随机筛选部分key，然后按照过期比例来判断是否需要重复执行筛选过期的动作。</p><p>​该策略由activeExpireCycle函数实现，每当服务器周期性的操作serverCron函数执行的时候，activeExpireCycle函数就会被调用，在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随你检查一部分的过期时间，并删除其中的过期键。具体代码在redis6在expire.c中，redis3在redis.c中。</p><p><strong>实现原理（activeExpireCycle函数）</strong></p><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内， 分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时 间，并删除其中的过期键。<br>整个过程可以用伪代码描述如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#默认每次检查的数据库数量</span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">#默认每个数据库检查的键数量</span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">#全局变量，记录检查进度</span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">def activeExpireCycle():</span><br><span class="line">    # 初始化要检查的数据库数量</span><br><span class="line">    # 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS 要小</span><br><span class="line">    # 那么以服务器的数据库数量为准</span><br><span class="line">    <span class="keyword">if</span> server.dbnum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line"># 遍历各个数据库</span><br><span class="line"><span class="keyword">for</span> i in range(db_numbers):</span><br><span class="line">    # 如果current_db 的值等于服务器的数据库数量</span><br><span class="line">    # 这表示检查程序已经遍历了服务器的所有数据库一次</span><br><span class="line">    # 将current_db 重置为<span class="number">0</span> ，开始新的一轮遍历</span><br><span class="line">    <span class="keyword">if</span> current_db == server.dbnum:</span><br><span class="line">        current_db = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">    # 获取当前要处理的数据库</span><br><span class="line">    redisDb = server.db[current_db]</span><br><span class="line"></span><br><span class="line">    # 将数据库索引增<span class="number">1</span> ，指向下一个要处理的数据库</span><br><span class="line">    current_db += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    # 检查数据库键</span><br><span class="line">    <span class="keyword">for</span> j in range(DEFAULT_KEY_NUMBERS):</span><br><span class="line">        # 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span><br><span class="line">        <span class="keyword">if</span> redisDb.expires.size() == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            #随机获取一个带有过期时间的键</span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line"></span><br><span class="line">            # 检查键是否过期，如果过期就删除它</span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">            # 已达到时间上限，停止处理</span><br><span class="line">            <span class="keyword">if</span> reach_time_limit(): <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>activeExpireCycle函数的工作模式总结</strong>：</p><p>函数每次运行时，都会从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键全局变量current_db会记录当前activeExpireCycle函数检查的进度，即当前查询到的数据库，并在下一次 activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前 activeExpireCycle函数在遍历完1号数据库完成过期键的删除后，那么下次activeExpireCycle函数执行时，将从2号数据库开始查找并删除过期键随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</p><h3 id="关于AOF、RDB对过期键的处理"><a href="#关于AOF、RDB对过期键的处理" class="headerlink" title="关于AOF、RDB对过期键的处理"></a>关于AOF、RDB对过期键的处理</h3><p><strong>1.生成RDB文件</strong></p><p>  在执行SAVE或者BGSAVE命令创建一个新的RDB文件的时候，程序会对数据库中的过期键进行检查，过期的键不会被保存到新创建的RDB文件中。<br><strong>2.载入RDB文件</strong></p><p>  载入的时候分为两种情况<br>  (1)服务器以主服务器运行。<br>  当服务器以主服务器运行的时候，会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期的键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。<br>  (2)服务器以从服务器运行。<br>  当服务器以从服务器运行的时候，会将文件中保存的所有键进行保存，不论是否过期。但是由于主从服务器进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键载入RDB文件的从高服务器也不会造成影响<br><strong>3.AOF文件的写入</strong></p><p>  当数据库中某个键已经过期，但是它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令进行显示的删除。<br><strong>4.AOF文件的重写：</strong></p><p>  重写的时候程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中这里有一个有意思的东西，当服务器运行在主从复制模式下的时候，从服务器的过期键删除动作是由主服务器控制的。主服务器在删除一个过期键后，会显示的向所有从服务器发送一个DEL命令，命令从服务器删除这个键；从服务器在执行客户端发送的命令的时候，即使遇到过期的键也不会将过期的键进行删除，是继续像处理未过期的键一样来处理过期键；从服务器只有在接到主服务器发送来的DEL命令的时候才会删除过期键。</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>通过上述对redis的对过期键的删除策略的介绍，可以发现无论是惰性删除策略还是定时删除策略，都会存在有过期键没有及时删除的情况，而在某些时刻有大量的键过期，同时又有大量的键要添加时，redis的内存空间就可能把占满，这时候如果想存入新的键，就必须引入内存淘汰策略，先淘汰掉一部分键，再把新的键存入。</p><h4 id="LRU和LFU算法"><a href="#LRU和LFU算法" class="headerlink" title="LRU和LFU算法"></a>LRU和LFU算法</h4><p>在介绍redis的内存淘汰策略之前，需要先了解一下两种淘汰最大空闲时间的策略LRU和LFU。</p><ul><li><strong>LRU算法</strong></li></ul><p>LRU（Least Recently Used），表示最近很少使用，也可以理解成最久没有使用。也就是说当内存不够的时候，每次添加一条数据，都需要抛弃一条最久时间没有使用的旧数据。标准的LRU算法一般会使用hash表和双向链表去降低查找和删除元素的时间复杂度，hash表可以赋予链表快速查找到某个key是否存在链表中，同时可以快速删除、添加节点。双向链表的查找时间复杂度是O(n)，删除和插入是O(1)，但是借助HashMap结构，可以使得查找的时间复杂度变成O(1)，Hash表用来查询在链表中的数据位置，链表负责数据的插入，当新数据插入到链表头部时有两种情况。</p><p>1）链表满了，把链表尾部的数据丢弃掉，新加入的缓存直接加入到链表头中。</p><p>2）当链表中的某个缓存被命中时，直接把数据移到链表头部，原本在头节点的缓存就向链表尾部移动。</p><p>这样，经过多次Cache操作之后，最近被命中的缓存，都会存在链表头部的方向，没有命中的，都会在链表尾部方向，当需要替换内容时，由于链表尾部是最少被命中的，我们只需要淘汰链表尾部的数据即可。</p><ul><li><strong>LFU算法</strong></li></ul><p>LFU（Least Frequently Used），表示最近最少使用，它和key的使用次数有关，其思想是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰，反之则保留。LFU的原理是使用计数器来对key进行排序，每次key被访问时，计数器会增大，当计数器越大，意味着当前key的访问越频繁，也就是意味着它是热点数据。 它很好的解决了LRU算法的缺陷：一个很久没有被访问的key，偶尔被访问一次，导致被误认为是热点数据的问题。LFU维护了两个链表，横向组成的链表用来存储访问频率，每个访问频率的节点下存储另外一个具有相同访问频率的缓存数据。具体的工作原理是：</p><p>1）当添加元素时，找到相同访问频次的节点，然后添加到该节点的数据链表的头部。如果该数据链表满了，则移除链表尾部的节点<br>2）当获取元素或者修改元素时，都会增加对应key的访问频次，并把当前节点移动到下一个频次节点</p><p>添加元素时，访问频率默认为1，随着访问次数的增加，频率不断递增。而当前被访问的元素也会随着频率增加进行移动。</p><p><strong>Redis中并不是完全采用LRU和LFU算法，内部做了一些优化，这里只是对这两种算法做一个简单的介绍，详细讲解请参考其他文章。</strong></p><h4 id="Redis中8种内存淘汰策略"><a href="#Redis中8种内存淘汰策略" class="headerlink" title="Redis中8种内存淘汰策略"></a>Redis中8种内存淘汰策略</h4><p><strong>1.noeviction</strong></p><p>不进行数据淘汰，也是Redis的默认配置。这时，当缓存被写满时，再有写请求进来，Redis不再提供服务，直接返回错误。</p><p> <strong>2.volatile-random</strong></p><p>缓存满了之后，在设置了过期时间的键值对中进行随机删除。</p><p><strong>3.volatile-ttl</strong></p><p>缓存满了之后，会针对设置了过期时间的键值对中，根据过期时间的先后顺序进行删除,越早过期的越先被删除。</p><p><strong>4.volatile-lru</strong></p><p>缓存满了之后，针对设置了过期时间的键值对，采用LRU算法进行淘汰。</p><p><strong>5.volatile-lfu</strong></p><p>缓存满了之后，针对设置了过期时间的键值对，采用LFU的算法进行淘汰。</p><p><strong>6.allkeys-random</strong></p><p>缓存满了之后，从所有键值对中随机选择并删除数据。</p><p><strong>7.allkeys-lru</strong></p><p>缓存写满之后，使用LRU算法在所有的数据中进行筛选删除。</p><p><strong>8.allkeys-lfu</strong></p><p>缓存满了之后，使用LRU算法在所有的数据中进行筛选删除。</p><p>在日常使用过程中，主要根据你的数据要求来配置相应的策略，这里我给你三点建议。</p><ul><li>我们优先使用allkeys-lru 策略。这样，我们就可以借助LRU算法去淘汰那些不常用的数据，把最近最常用的放在缓存中，从而提高应用的性能。如果你的数据有明显的冷热区分，建议你使用allkeys-lru策略。</li><li>如果你的数据的访问频率相差不大，也没有冷热之分，直接使用allkeys-random 策略，随机选择淘汰的数据就行。</li><li>如果你的数据有置顶要求，比如置顶新闻等。那么我们就选择volatile-lru策略，同时不给置顶数据设置过期时间，这样一来，置顶的数据永远不会被删除，而其他设置了过期时间的数据，会更加LRU算法进行淘汰</li></ul><p><strong>注意</strong>：基于LFU算法的策略是Redis4.0版本之后增加的，如要使用，请注意自己的redis版本。</p><h4 id="如何获取及设置内存淘汰策略"><a href="#如何获取及设置内存淘汰策略" class="headerlink" title="如何获取及设置内存淘汰策略"></a>如何获取及设置内存淘汰策略</h4><p>1、获取当前内存淘汰策略：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory-policy</span><br></pre></td></tr></table></figure><p>可以看到当前使用的默认的noeviction策略</p><p>2、获取Redis能使用的最大内存大小</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config get maxmemory</span><br></pre></td></tr></table></figure><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位机器限制最大 3 GB 的可用内存</p><p>3、设置淘汰策略</p><p>通过配置文件设置淘汰策略（修改redis.conf文件）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>通过命令修改淘汰策略：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>4、设置Redis最大占用内存大小</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#设置Redis最大占用内存大小为<span class="number">100</span>M</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; config set maxmemory <span class="number">100</span>mb</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的过期键的删除策略&quot;&gt;&lt;a href=&quot;#Redis的过期键的删除策略&quot; class=&quot;headerlink&quot; title=&quot;Redis的过期键的删除策略&quot;&gt;&lt;/a&gt;Redis的过期键的删除策略&lt;/h2&gt;&lt;p&gt;Redis是一种基于内存的高性能键值对(ke</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://wangchengji.github.io/fwzssd/bae4ff13.html"/>
    <id>https://wangchengji.github.io/fwzssd/bae4ff13.html</id>
    <published>2022-09-01T03:50:06.000Z</published>
    <updated>2022-09-06T01:46:51.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>简介：Redis(REmote DIctionary Server)是用c语言开发的一个开源的高性能键值对(key-value)数据库，Redis 是一个开源（BSD许可）的，<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。是一个NoSQL数据库，NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a><strong>特征：</strong></h4><ul><li><p>高性能。</p><p>内存存储，不走磁盘<code>IO</code>，在大数据量下也可以高性能运行。</p><p>官方提供测试数据，50个并发执行100000个请求,读110000 次&#x2F;s,写81000次&#x2F;s</p></li><li><p>数据结构丰富</p><p>支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及<code>zset</code>(sorted set：有序集合)。</p></li><li><p>原子性</p><p>核心读写部分是单线程的，排队执行，对应的操作便具有了原子性，避免了多线程操作带来的复杂性和不安全因素。Redis6.0开始，网络传输支持多线程。</p></li><li><p>易拓展。</p><p>关系型数据库中记录、表关系复杂，扩容难度高；<code>NoSQL</code>中数据无关系，<code>Redis</code>3.0开始支持集群，扩容简单。</p></li><li><p>高可用。（高并发、高可用、高性能）</p><p><code>Redis</code>3.0开始支持集群，可以多主多从，当某个节点发生异常时，可以由其他对应节点顶替，保持整个集群的高可用。</p></li><li><p>可持久化（异地灾备）</p><p>支持把数据持久化存储到磁盘中，以便下次启动或遇到故障时，从磁盘加载恢复数据。</p></li></ul><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p><strong>支持的数据类型</strong>（值支持的类型如下，键只有<code>String</code>）</p><ul><li><table><thead><tr><th>支持类型</th><th>表示形式</th></tr></thead><tbody><tr><td>字符串类型</td><td><code>string</code>(普通字符串，常用)</td></tr><tr><td>列表类型</td><td><code>list</code>(按照插入顺序排序，可以有重复元素，可做消息队列)</td></tr><tr><td>Hash类型</td><td><code>hash</code>(适合存储对象)</td></tr><tr><td>集合类型</td><td><code>set</code>(无序集合，没有重复元素)</td></tr><tr><td>有序集合类型</td><td><code>zset/sorted_set</code>(集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素)</td></tr></tbody></table></li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><span style="color:blue"><strong>应用场景：</strong></span></h4><ul><li><span style="color:red">缓存</span>。查询频率较高，长久保存，但又不经常变化的数据。</li><li><span style="color:red">即时信息</span>。临时性的，经常变化的数据。</li><li><code>Session</code>共享。解决分布式系统中<code>session</code>共享的问题。</li><li>其他。诸如：时效性信息、消息队列（MQ MessageQueue）等</li></ul><h3 id="安装配置启动："><a href="#安装配置启动：" class="headerlink" title="安装配置启动："></a>安装配置启动：</h3><ul><li><p><strong>windows下安装运行：</strong></p><p> 下载安装：到GitHub上 <a href="https://github.com/ServiceStack/redis-windows">ServiceStack&#x2F;redis-windows：Vagrant redis configuration 和 MS Open Tech redis port of windows 的二进制版本 (github.com)</a> 下载安装包，解压即完成安装；</p><p>运行：解压目录两个文件分别启动服务端（redis-cli.exe）和客户端（redis-cli.exe），双击启动(默认端口(6379)、默认配置启动)。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果双击客户端cmd窗口一闪而过，可以尝试在redis-cli.exe所在目录下打开cmd窗口输入</span></span><br><span class="line">redis-server.exe redis.windows.conf </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server.exe --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server.exe redis.conf --port 6380</span><br></pre></td></tr></table></figure><p>客户端连接服务端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接本机上服务端默认端口</span></span><br><span class="line">redis-cli.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接本机上服务端指定端口</span></span><br><span class="line">redis-cli.exe -h 192.168.115.130 -p 6380</span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>linx中下载安装运行：</strong></p><p>下载：登录<code>redis.cn</code>（ <a href="http://download.redis.io/releases/">Index of &#x2F;releases&#x2F; (redis.io)</a> ）下载自己需要下载指定版本的安装包；</p><p>安装和启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0.准备工作1：安装wget</span></span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.准备工作2：安装gcc编译环境</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.在/usr/loca目录（用户软件安装目录）创建redis文件夹（包括data文件夹、log文件夹）</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.上传/下载redis安装包到centos，下面两个步骤（1.1和1.2）任选其一即可</span></span><br><span class="line"><span class="comment"># 1.1 上传离线安装包，上传redis安装包到centos7</span></span><br><span class="line"><span class="comment"># crt工具 Alt + p 打开sftp窗口，通过put命令上传到登录用户的home目录</span></span><br><span class="line">put redis-linux-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剪切压缩包到安装目录</span></span><br><span class="line"><span class="built_in">mv</span> /root/redis-linux-5.0.5.tar.gz /usr/local/redis/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 在线下载安装包（需要安装好了wget）</span></span><br><span class="line">wget -P /usr/local/redis http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入redis目录</span></span><br><span class="line"><span class="built_in">cd</span>  /usr/local/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解压到当前目录</span></span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进入解压目录，执行编译</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 进入src目录，可以看到服务端和客户端的启动程序</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server</span><br><span class="line">./redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 6.新建数据目录和日志目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-5.0.5/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 在任意位置位置启动Redis-server</span></span><br><span class="line"><span class="comment"># 打开linux配置path的文件,</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#在文件末尾添加下面两行,其中REDIS_HOME的值是redis安装的根目录</span></span><br><span class="line"><span class="built_in">export</span> REDIS_HOME=/usr/local/redis/redis-5.0.5</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$REDIS_HOME</span>/src:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p> 指定端口&#x2F;配置文件启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认端口启动服务端</span></span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口使用默认配置文件启动</span></span><br><span class="line">redis-server --port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口、指定配置文件启动</span></span><br><span class="line">redis-server ../redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接非默认端口的服务端</span></span><br><span class="line">redis-cli -p 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用密码连接</span></span><br><span class="line">redis-cli -p 6380 -a 123456</span><br><span class="line"><span class="comment"># 或者连接后使用指定的命令认证</span></span><br><span class="line">auth 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体上和Windows一致</span></span><br></pre></td></tr></table></figure><p>测试是否可连接(在客户端)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> blog blog.sunxiaowei.net</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get blog</span><br><span class="line"><span class="string">&quot;blog.sunxiaowei.net&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)<span class="comment">#数据库为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切库 select n</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用docker快速部署redis</strong></p><p> 进入dockerHub官网，查询redis镜像<a href="https://hub.docker.com/_/redis%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9C%80%E6%B1%82%E6%8C%89%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E3%80%82">https://hub.docker.com/_/redis，根据自己的需求按官方文档下载镜像和配置容器。</a></p></li><li><p><strong>退出</strong></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(`quit`、`<span class="built_in">exit</span>`、`ctrl + C` 、`Ctrl +D`)任选其一</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p><p> 宿主机连接虚拟机中的<code>redis</code>服务时，需要关闭保护模式或者绑定对应的<code>redis</code>服务所在设备的网卡。</p></li></ul><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><p>通过修改配置文件，可以让Redis服务运行在不同端口上、允许通过不同的网卡连接等。</p><ul><li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li><li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li></ul><h4 id="常见配置如下"><a href="#常见配置如下" class="headerlink" title="常见配置如下"></a>常见配置如下</h4><p><strong>1）设置Redis服务运行的端口</strong></p><p>port 6379</p><p><strong>2）设置Redis服务后台运行</strong></p><p>​将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p><p>​注意：Windows版的Redis不支持后台运行。</p><p><strong>3）</strong>设置<code>Redis</code>服务密码(如果是云主机建议设置密码)</p><p>​将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p><p><strong>4）</strong>设置允许客户端远程连接Redis服务</p><p>​远程连接redis注意防火墙设置</p><p>​Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p><p><strong>解释说明：</strong></p><blockquote><p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p><p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p><p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p><p>requirepass：设置Redis的连接密码</p><p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p></blockquote><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><h4 id="字符串string操作命令"><a href="#字符串string操作命令" class="headerlink" title="字符串string操作命令"></a>字符串string操作命令</h4><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><h4 id="哈希hash操作命令"><a href="#哈希hash操作命令" class="headerlink" title="哈希hash操作命令"></a>哈希hash操作命令</h4><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><h4 id="列表list操作命令"><a href="#列表list操作命令" class="headerlink" title="列表list操作命令"></a>列表list操作命令</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><h4 id="集合set操作命令"><a href="#集合set操作命令" class="headerlink" title="集合set操作命令"></a>集合set操作命令</h4><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><h4 id="有序集合sorted-set操作命令"><a href="#有序集合sorted-set操作命令" class="headerlink" title="有序集合sorted set操作命令"></a>有序集合sorted set操作命令</h4><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </li><li><strong>EXISTS</strong> key  检查给定 key 是否存在</li><li><strong>TYPE</strong> key  返回 key 所储存的值的类型</li><li><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</li></ul><h4 id="学习站"><a href="#学习站" class="headerlink" title="学习站"></a>学习站</h4><p>更多命令可以参考<a href="https://www.redis.net.cn/tutorial/3516.html">Redis中文网</a>或<a href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程</a>。</p><h3 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jedis操作Redis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 执行具体的操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis.del(&quot;username&quot;);</span></span><br><span class="line"></span><br><span class="line">        jedis.hset(<span class="string">&quot;myhash&quot;</span>,<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hValue</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;addr&quot;</span>);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataredis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springdataredis_demo</span></span><br><span class="line">  <span class="comment">#Redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#操作的是0号数据库</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="comment">#Redis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">4</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><p>第四步：提供配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><p>第五步：提供测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作字符串类型数据"><a href="#操作字符串类型数据" class="headerlink" title="操作字符串类型数据"></a>操作字符串类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作String类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>,<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;city123&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，同时设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="number">10l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，如果存在则不执行任何操作</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;city1234&quot;</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    System.out.println(aBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作哈希类型数据"><a href="#操作哈希类型数据" class="headerlink" title="操作哈希类型数据"></a>操作哈希类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Hash类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有字段</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有值</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作列表类型数据"><a href="#操作列表类型数据" class="headerlink" title="操作列表类型数据"></a>操作列表类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作List类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    List&lt;String&gt; mylist = listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String value : mylist) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得列表长度 llen</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> size.intValue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">        <span class="comment">//出队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作集合类型数据"><a href="#操作集合类型数据" class="headerlink" title="操作集合类型数据"></a>操作集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Set类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="操作有序集合类型数据"><a href="#操作有序集合类型数据" class="headerlink" title="操作有序集合类型数据"></a>操作有序集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作ZSet类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">11.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">12.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">13.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改分数</span></span><br><span class="line">    zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用操作，针对不同的数据类型都可以操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取Redis中所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个key是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">itcast</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定key</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定key对应的value的数据类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;h3 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://wangchengji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://wangchengji.github.io/fwzssd/c24675b4.html"/>
    <id>https://wangchengji.github.io/fwzssd/c24675b4.html</id>
    <published>2022-08-28T09:21:22.000Z</published>
    <updated>2022-08-28T10:23:10.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL相关知识"><a href="#MySQL相关知识" class="headerlink" title="MySQL相关知识"></a>MySQL相关知识</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="七大事务传播行为"><a href="#七大事务传播行为" class="headerlink" title="七大事务传播行为"></a>七大事务传播行为</h5><ol><li><p><strong>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</strong></p></li><li><p><strong>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</strong></p></li><li><p><strong>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</strong></p></li><li><p><strong>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</strong></p></li><li><p><strong>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</strong>(新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作；)</p></li><li><p><strong>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</strong></p></li><li><p><strong>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作</strong>。(嵌套事物是子事物套在父事物中执行，子事物是父事物的一部分，在进入子事物之前，父事物建立一个回滚点，叫save point，然后执行子事物，这个子事物的执行也算是父事物的一部分，然后子事物执行结束，父事物继续执行。重点就在于那个save point)</p></li></ol><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul><li><p><strong>读未提交（read Uncommited）:</strong> </p><p>在该隔离级别，所有的事务都可以读取到别的事务中未提交的数据，会产生脏读问题，在项 目中基本不怎么用， 安全性太差；</p></li><li><p><strong>读已提交（read commited）:</strong> </p><p>这是大多数数据库默认的隔离级别，但是不是 MySQL 的默认隔离级别；这个隔离级别满足 了简单的隔离要求：一个事务只能看见已经提交事务所做的改变，所以会避免脏读问题； 由于一个事务可以看到别的事务已经提交的数据，于是随之而来产生了不可重复读和虚读等 问题；</p></li><li><p><strong>可重复读（Repeatable read）：</strong> </p><p> 这是 MySQL 的默认隔离级别，它确保了一个事务中多个实例在并发读取数据的时候会读取 到一样的数据；不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简 单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当 36 用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通 过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题；</p></li><li><p><strong>可串行化（serializable）：</strong></p><p> 事物的最高级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之， 它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争，一 般为了提升程序的吞吐量不会采用这个；</p></li></ul><h5 id="脏读、不可重复读、可重复读、幻读"><a href="#脏读、不可重复读、可重复读、幻读" class="headerlink" title="脏读、不可重复读、可重复读、幻读"></a>脏读、不可重复读、可重复读、幻读</h5><ul><li><p><strong>dirty reads（脏读）：</strong>就是说事务A未提交的数据被事务B读走，如果事务A失败回滚，将导致B所读取的数据是错误的。</p></li><li><p><strong>non-repeatable reads（不可重复读）：</strong>，就是说事务A中两处读取数据，第一次读时是100，然后事务B把值改成了200，事务A再读一次，结果就发现值变了，造成A事务数据混乱。</p></li><li><p><strong>phantom read（幻读）：</strong>，和不可重复读相似，也是同一个事务中多次读不一致的问题。但是不可重复读的不一致是因为它所要取的数据集被改变了，而幻读所要读的数据不一致却不是他所要读的数据改变，而是它的条件数据集改变。比如：Select id where name&#x3D;”ppgogo*”，第一次读去了6个符合条件的id，第二次读时，由于事务B把第一个贴的名字由”dd”改成了“ppgogo9”，结果取出来7个数据。</p></li><li><p><strong>可重复读：</strong>在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据。</p></li></ul><h5 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h5><ol><li><strong>原子性：</strong>即不可分割性，事务要么全部被执行，要么就全部不被执行；</li><li><strong>一致性：</strong>事务的执行使得数据库从一种正确状态转换成另一种正确状态 ；</li><li><strong>隔离性：</strong>在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务；</li><li><strong>持久性：</strong>事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障， 事务的处理结果也会得到保存。</li></ol><h4 id="MySQL解决可重复读和幻读的机制"><a href="#MySQL解决可重复读和幻读的机制" class="headerlink" title="MySQL解决可重复读和幻读的机制"></a>MySQL解决可重复读和幻读的机制</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL相关知识&quot;&gt;&lt;a href=&quot;#MySQL相关知识&quot; class=&quot;headerlink&quot; title=&quot;MySQL相关知识&quot;&gt;&lt;/a&gt;MySQL相关知识&lt;/h3&gt;&lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySql索引</title>
    <link href="https://wangchengji.github.io/fwzssd/756c412e.html"/>
    <id>https://wangchengji.github.io/fwzssd/756c412e.html</id>
    <published>2022-08-27T01:15:22.000Z</published>
    <updated>2022-08-27T10:10:24.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL的索引的相关知识总结："><a href="#MySQL的索引的相关知识总结：" class="headerlink" title="MySQL的索引的相关知识总结："></a><strong>MySQL的索引的相关知识总结：</strong></h3><p>索引的概述：索引就是高效获取数据的数据结构</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul><li>优点<ol><li>提高数据检索的效率，降低数据库IO成本；</li><li>提高排序效率，通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li></ol></li><li>缺点：<ol><li>索引列会占用部分磁盘空间；</li><li>索引大大提高了查询的效率，同时降低了更新表的速度，关于对表的insert、update、delete操作，效率降低。</li></ol></li><li>总结：因为大多数表在使用的过程中，查询相关的SQL占到百分之95以上，而相较于CPU和内存来说，磁盘的占用带来的成本基本可用忽略，所以为了提高数据的检索效率而使用索引是非常有必要的。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><ul><li><p>B-tree特点：</p><ol><li><p>当节点中的索引key达到上限时中间的key会分裂出去；                         </p></li><li><p>所有的key都会出现在叶子节点，而所有的数据都存储在这些叶子节点上；</p></li><li><p>叶子节点形成一个单项链表。</p><p><img src="https://pic.imgdb.cn/item/6309dad716f2c2beb18d31d5.png"></p></li></ol></li><li><p>B+tree特点：</p><p>MySQL索引数据结构对经典的B-tree进行了优化。在原B-tree的基础上，增加一个指向相邻叶子节点的链表指针，形成了双向链表，就形成了带有顺序指针的B+tree，提高了区间访问的性能。</p><p><img src="https://pic.imgdb.cn/item/6309daf116f2c2beb18d407d.png"></p></li><li><p>Hash索引（Memory引擎）特点：</p><ol><li>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中，而如果存在hash冲突的键值（两个或者多个键值hash值相同），可以在对应槽位上增加链表来存储键值；</li><li>Hash索引只能用于对等比较（&#x3D;，in），不支持服务查询（between，&gt;,&lt;,…）;    </li><li>无法利用索引完成排序操作；  </li><li>查询效率高，通常情况只需要一次检索就可以了，效率通常要高于B+tree索引。</li></ol></li><li><p>为什么InnoDB存储引擎选择使用B+tree索引结构？</p><ol><li><p>相对于二叉树，B+tree的层级更加少，可以减少磁盘IO的次数，提高搜索效率；</p></li><li><p>相对于B-tree，因为在Mysql中一个节点代表一个分页，一个分页的大小是有限的（16kb），而B-tree中数据和索引存储在一个节点中，这样就会使得存储在一个节点上的key减少，造成树的高度增加，导致检索数据时磁盘IO次数增加，性能降低；</p></li><li><p>相对于Hash索引，B+tree支持的访问匹配和排序操作，叶子节点的双向链表结构便于范围搜索和排序。</p></li></ol></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键索引</td><td align="left">针对于表中主键创建的索引</td><td align="left">默认自动创建，且只能有一个</td><td align="left">primary</td></tr><tr><td align="left">唯一索引</td><td align="left">避免同一个表中某个数据列中存在相同数据</td><td align="left">可以有多个</td><td align="left">unique</td></tr><tr><td align="left">常规索引</td><td align="left">快速定位特定数据</td><td align="left">可以有多个</td><td align="left"></td></tr><tr><td align="left">全文索引</td><td align="left">全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td align="left">可以有多个</td><td align="left">fulltext</td></tr></tbody></table><p><strong>在InnDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</strong></p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（Clustered index）</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只能有一个</td></tr><tr><td>二级索引（Secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p><strong>聚集索引选取规则：</strong></p><ol><li>如果存在主键，主键索引就是聚集索引；</li><li>如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引；</li><li>如果表没有主键，或没有合适的唯一索引，则InnDB会自动生成一个rowid作为隐藏5的聚集索引。</li></ol><p><strong>简单点说</strong>聚集索引通过主键列上的值创建索引，把整行数据存储在索引所在叶子节点的下面，而二级索引就是通过索引列上的数据创建索引，而在叶子节点下存储的是该行数据的主键。</p><p><strong>InnoDB主键索引的B+tree高度为多高呢？？</strong></p><p>假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。则：</p><p>树高度为2：<br>n<em>8+(n+1)<em>6&#x3D;16</em>1024（一个节点指针比key多一个，一个节点大小为16k）n≈1170 1171</em>16&#x3D;18736<br> 树高度为3：                                                                                                                                           1171<em>1171</em>16&#x3D;21939856</p><h4 id="索引相关操作（SQL）"><a href="#索引相关操作（SQL）" class="headerlink" title="索引相关操作（SQL）"></a>索引相关操作（SQL）</h4><ol><li><p>查询索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure></li><li><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] [fulltext] index 索引名字（自己取） <span class="keyword">on</span>  表名（要添加索引的字段名，可以是多个字段，多字段代表创建联合索引）；</span><br></pre></td></tr></table></figure></li><li><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名。</span><br></pre></td></tr></table></figure></li></ol><h4 id="查询需要优化的SQL（运行慢的SQL）"><a href="#查询需要优化的SQL（运行慢的SQL）" class="headerlink" title="查询需要优化的SQL（运行慢的SQL）"></a>查询需要优化的SQL（运行慢的SQL）</h4><ul><li><p>查看当前数据库状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志：开启慢查询日志定位查询效率低的<code>sql</code>：</p><p>慢查询日志记录了所有执行时间超过指定参数（<code>long_query_time</code>,单位：秒，默认10秒）的所有<code>SQL</code>语句日志。<code>MySQL</code>的慢查询日志默认没有开启，需要在<code>MySQL</code>的配置文件（<code>/etc/my.cnf</code>）中做如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢日志查询</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被认定是慢查询，记录到查询日志</span><br><span class="line">log_query_time=2</span><br></pre></td></tr></table></figure><p>配置完成后，重启MySQL服务器测试，</p><p>查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code>。</p></li><li><p>profile详情查询sql执行时间：</p><p>查看数据库是否支持profile：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>开启profile查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>执行想判断的SQL，然后通过下面指令查询SQL的执行时间：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看每一条<span class="keyword">sql</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles；</span><br><span class="line"></span><br><span class="line">#查看指定query id 的<span class="keyword">sql</span>语句各阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">sql</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li><li><p>explain执行计划:</p><p>语法：explain  + select 语句;</p><p>explain中各字段含义：</p><ol><li>id：select查询的序列号，表示查询中执行select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。连表查询中一般两张表的id都相同且按from后表的顺序查询；如果有子查询子查询中的select的id会更大，子查询先执行。</li><li>select_type：表示select的类型，常见的取值有simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select&#x2F;where之后包含了子查询）等。</li><li>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。<ul><li>NULL：业务代码中一般不太可能达到，不查询表的select查询：select ’A’；</li><li>system：一般出现在查询系统表时;</li><li>const：按主键索引查询;</li><li>ref：一般是二级索引查询;</li><li>range：范围匹配查询;</li><li>index：索引全表扫描;</li><li>all：全表扫描.</li></ul></li><li>possible_key：可能应用在这张表上的索引。</li><li>key：实际用到的索引.</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li>rows：MYSQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</li><li>filtered：表示返回结果的行数占读取行数的百分比，这个值越大越好。</li><li>Extra：其他信息。</li></ol><h4 id="索引使用相关规则"><a href="#索引使用相关规则" class="headerlink" title="索引使用相关规则"></a>索引使用相关规则</h4><ol><li><p><strong>最左前缀法则：</strong>使用联合索引查询时，必须遵守最左前缀法则；即where条件在必须包含复合索引中最左边第一个字段的条件，否则索引不生效，按照索引中字段的顺序，如果条件中不存在中间某个字段的条件，则后面字段的索引也不会生效。（注：where条件中只需要包含相关字段添加即可，条件顺序的并不影响索引的使用）联合查询中使用了范围查询（&gt;,&lt;）：范围查询右侧的列索引生效，在业务允许的条件下可以使用&lt;&#x3D;和&gt;&#x3D;索引就又可以使用了。</p></li><li><p><strong>不能在条件上加函数运算，否则索引将失效。</strong></p></li><li><p><strong>字符串不加引号，会引发隐式类型转换，导致索引失效。</strong></p></li><li><p><strong>模糊查询like：%加前面索引失效，%加后面索引还是生效的。%xx(失效)、xx%（生效）。</strong></p></li><li><p><strong>or连接条件：如果or两侧列都有索引则通过两侧索引查询，如果存在一侧没有索引则来一侧存在索引的列索引会失效。</strong></p></li><li><p><strong>数据评估影响（mysql实现）：如果查询的数据占了表中的大头，mysql判断使用全表扫描效率更高，mysql就会放弃使用索引，进行全表扫描。</strong></p></li><li><p><strong>SQL提示：是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</strong></p><ul><li><p>use index（索引名)   </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ignore index（索引名）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 忽略使用该索引，让这次查询不使用该索引。</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>force index（索引名） </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制此次查询使用该索引</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>覆盖索引</strong>：</p></li></ol><ul><li><p>什么是回表查询？</p><p>场景：存在一张表user有3个字段主键id、name、age；列name存在二级索引，当我们使用select * from user where name &#x3D; ‘zs’,此时就存在回表查询。</p><p>解释：上述sql会根据name字段的二级索引进行查询，但是name字段上的二级索引只保存了name上的值和id，而我们使用select * 查询全字段信息，而age字段的信息是无法通过name字段的二级索引查询到的，这时候就需要进行回表查询，通过二级索引查询到的id再通过主键id的聚集索引查询到这条数据的所有信息。</p></li><li><p>覆盖索引避免回表查询：</p><p>可以使用联合索引，把经常需要查的字段信息合并到一个联合索引中，在select 后只添加这些需要查询的字段，即可通过二级索引就获得需要的字段信息，避免回表查询。</p></li></ul><ol start="9"><li><strong>前缀索引</strong>：</li></ol><ul><li><p>应用场景：大文本或者数据列建立索引时只截取文本前指定长度的数据当做索引。</p></li><li><p>索引长度指定规则：</p><p>当字段类型为字符串（varchar，text等）时,有时候需要索引很长的字符串，这样会让索引变得很大，因为节点的大小有限，单个索引变大，单个节点内可以存储的索引数量就会减少，树的高度就会增加，查询时，浪费大量的磁盘IO，影响查询效率。此时可以用字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure></li><li><p>前缀长度选择：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引过多，维护索引结构的代价就会过大，会影响增删改的效率。</li><li>如果索引列不能存储null值，请在创建表的时候使用not null约束它，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有利于查询。</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;a href=&quot;#MySQL的索引的相关知识总结：&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;/a&gt;&lt;strong&gt;MySQL的索引的相关知识总结：&lt;/strong&gt;&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="https://wangchengji.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Development Tool</title>
    <link href="https://wangchengji.github.io/fwzssd/60588ca5.html"/>
    <id>https://wangchengji.github.io/fwzssd/60588ca5.html</id>
    <published>2022-08-26T07:21:03.000Z</published>
    <updated>2022-08-27T10:12:56.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发过程中相关工具的下载："><a href="#java开发过程中相关工具的下载：" class="headerlink" title="java开发过程中相关工具的下载："></a>java开发过程中相关工具的下载：</h2><h4 id="JDK的下载和环境配置："><a href="#JDK的下载和环境配置：" class="headerlink" title="JDK的下载和环境配置："></a>JDK的下载和环境配置：</h4><ul><li><p><input disabled="" type="checkbox"> jdk的下载（建议下载1.8和11的版本）：</p><ol><li><p>打开浏览器输入网址 <a href="https://www.oracle.com/index.html%EF%BC%8C%E8%BF%9B%E5%85%A5[Oracle%E5%AE%98%E7%BD%91](https://www.oracle.com/index.html)">https://www.oracle.com/index.html，进入[Oracle官网](https://www.oracle.com/index.html)</a> ，在<code>Producet</code>下找到<code>Java</code>根据自己的操作系统选择对应的版本进行下载；</p></li><li><p>jdk安装：</p><p> 2.1 下载完JDK到本地后，找到该文件，双击运行JDK安装程序 ，进入JDK安装界面，点击下一步； </p><p>2.2 可以直接默认目录，点击下一步。也可以自定义路径，先创建一个文件夹名为Java，再在该文件夹下创建一个文件夹为JDK安装目录，同时创建一个文件夹为JRE安装目录 ；</p><p> 2.3然后回到JDK安装界面，更改安装路径，为上述所创建的JDK路径，点击下一步（<strong>这里由于第一项开发工具中已经自带了 JRE，则第三项的公共 JRE 可以取消独立安装，上述创建的 JRE 文件夹也不需要了</strong>）。无其他需求，取消安装JRE即可；</p><p>2.4等待一会，会进入 JRE 的安装界面，同样的更改路径，为上述所创建的 JRE 路径，更改完之后点击下一步（<strong>在上一步取消公共 JRE 安装的则不会出现下面的界面，直接到 2.5 安装完成</strong>）； </p><p>2.5至此JDK已经安装完毕，点击关闭 ；</p><p>2.6测试是否安装成功：可以进入安装好的jdk中的bin目录下打开cmd窗口运行<code>java -version</code>出现信息即可。</p></li><li><p>windows版本的jdk百度网盘下载：链接: <a href="https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8">https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8</a> 提取码: k8d8 复制这段内容后打开百度网盘手机App，操作更方便哦</p></li></ol></li><li><p><input disabled="" type="checkbox"> jdk运行环境的配置（为了在任何终端都可以使用jdk）：</p><p>1.windows操作系统中找到系统的高级设置；</p></li></ul><p>​       2.找到环境变量</p><p>​       3.点击新增；</p><p>​       4.新增变量<code>JAVA_HOME</code>，变量值是安装的jdk的根目录（包含bin目录的那个目录）；</p><p>​       5.找到变量<code>Path</code>新增变量 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code> ；</p><p>​       6.测试，在任意终端输入<code>javac</code>得到java配置信息即表示配置成功。</p><h4 id="idea下载和破解："><a href="#idea下载和破解：" class="headerlink" title="idea下载和破解："></a>idea下载和破解：</h4><ul><li><p><input disabled="" type="checkbox"> idea的安装包的下载（建议不要下载过新的版本，使用20~21版本即可方便破解）：</p><ol><li><p>打开浏览器输入<a href="https://www.jetbrains.com/%EF%BC%8C%E8%BF%9B%E5%85%A5">https://www.jetbrains.com/，进入</a> <a href="https://www.jetbrains.com/">Jetbrains官网</a>，点击 Developer Tools，再点击 Intellij IDEA ；</p></li><li><p>点击中间的download，进入IDEA下载界面 ；</p></li><li><p>选择左边的Ultimate版本进行下载安装。Ultimate版本为旗舰版，需要付费，包括完整的功能。Community 版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，后续进行激活 ；</p></li></ol></li><li><p><input disabled="" type="checkbox"> ​     idea安装：</p><ol><li><p>下载完后在本地找到该文件，双击运行 idea 安装程序 ；</p></li><li><p>点击 Next ；</p></li><li><p>选择安装路径，Next ；</p></li></ol></li></ul><p>​          4.按需求选择，点击 Next ,版本不同有不同的选择，之前版本可能需要选择电脑的版本；</p><p>​          5.默认，不用改，直接点 Install，安装 ；</p><p>​         6.安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA 。</p><ul><li><p><input disabled="" type="checkbox"> 破解idea：</p><p>破解idea主要有两种破解方式，永久版破解到2099年，参考 <a href="http://www.itmind.net/13082.html">IntelliJ IDEA 2021.3.3破解教程（亲测有效，激活至2099年） (itmind.net)</a> ；刷新试用时间版，参考 <a href="http://www.itmind.net/12400.html">2022年IntelliJ IDEA最新破解教程，无限重置试用期 (亲测有效) (图文教程) (itmind.net)</a> ；刷新试用时间的破解方式比较容易操作。</p><p>（内附2021版本idea下载破解商品链接: <a href="https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA">https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA</a> 提取码: 865s 复制这段内容后打开百度网盘手机App，操作更方便哦）</p></li></ul><h4 id="maven的下载和配置："><a href="#maven的下载和配置：" class="headerlink" title="maven的下载和配置："></a>maven的下载和配置：</h4><p>1.官网 <a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a> 下载压缩包；</p><p>2.放到安装目录直接解压即可；</p><p>3.国内访问中央仓库过慢，在config包的setting.xml中配置阿里云的镜像地址，加速依赖下载；</p><p>在<mirrors>标签中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.环境配置：和jdk一样，在系统的环境变量中配置maven的变量；</p><p>变量名：MAVEN_HOME</p><p>变量值：maven的根目录</p><p>5.在<code>path</code>变量中新增<code>%MAVEN_HOME%\bin</code>变量</p><h4 id="git的下载："><a href="#git的下载：" class="headerlink" title="git的下载："></a>git的下载：</h4><p>1.进入官网 <a href="https://git-scm.com/">吉特 (git-scm.com)</a> 下载安装包；</p><p>2.双击安装包安装，一直点击next,直到出现install,点击install,然后点击finish，安装完成。 </p><p>3.安装完成后，桌面右键出现Git GUI、Git bash选项，说明已安装： </p><h4 id="数据库图形化软件："><a href="#数据库图形化软件：" class="headerlink" title="数据库图形化软件："></a>数据库图形化软件：</h4><p>1.下载破解Navicat： <a href="http://www.itmind.net/13042.html">Navicat Premium 15 破解激活教程,永久有效(亲测可用) (itmind.net)</a> </p><p>或者 <a href="https://www.downkuai.com/soft/150597.html">Navicat 16破解版(附激活秘钥)下载-Navicat premium 16破解版下载 v16.0.4附安装破解教程-当快软件园 (downkuai.com)</a> </p><h4 id="Redis图形化软件："><a href="#Redis图形化软件：" class="headerlink" title="Redis图形化软件："></a>Redis图形化软件：</h4><p>1.RedisDesktopManager安装包链接: <a href="https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law">https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law</a> 提取码: 8s8d 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>2.QuickRedis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;a href=&quot;#java开发过程中相关工具的下载：&quot; class=&quot;headerlink&quot; title=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;/a&gt;java开发过程中相关工具的下载：&lt;/h2&gt;&lt;h4 id=&quot;JDK的下</summary>
      
    
    
    
    
    <category term="Java" scheme="https://wangchengji.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangchengji.github.io/fwzssd/4a17b156.html"/>
    <id>https://wangchengji.github.io/fwzssd/4a17b156.html</id>
    <published>2022-08-25T09:37:53.819Z</published>
    <updated>2022-08-27T10:11:56.740Z</updated>
    
    <content type="html"><![CDATA[<p>快速发布新文章</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到线上"><a href="#发布到线上" class="headerlink" title="发布到线上"></a>发布到线上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速发布新文章&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;新增文章&quot;&gt;&lt;a href=&quot;#新增文章&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://wangchengji.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
