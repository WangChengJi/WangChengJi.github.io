<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凉人夢</title>
  
  <subtitle>十里八乡有名的俊后生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-27T08:36:12.707Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>WangChengJi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql索引</title>
    <link href="http://example.com/fwzssd/756c412e.html"/>
    <id>http://example.com/fwzssd/756c412e.html</id>
    <published>2022-08-27T01:15:22.000Z</published>
    <updated>2022-08-27T08:36:12.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL的索引的相关知识总结："><a href="#MySQL的索引的相关知识总结：" class="headerlink" title="MySQL的索引的相关知识总结："></a><strong>MySQL的索引的相关知识总结：</strong></h3><p>索引的概述：索引就是高效获取数据的数据结构</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><ul><li>优点<ol><li>提高数据检索的效率，降低数据库IO成本；</li><li>提高排序效率，通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li></ol></li><li>缺点：<ol><li>索引列会占用部分磁盘空间；</li><li>索引大大提高了查询的效率，同时降低了更新表的速度，关于对表的insert、update、delete操作，效率降低。</li></ol></li><li>总结：因为大多数表在使用的过程中，查询相关的SQL占到百分之95以上，而相较于CPU和内存来说，磁盘的占用带来的成本基本可用忽略，所以为了提高数据的检索效率而使用索引是非常有必要的。</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><ul><li><p>B-tree特点：</p><ol><li><p>当节点中的索引key达到上限时中间的key会分裂出去；                         </p></li><li><p>所有的key都会出现在叶子节点，而所有的数据都存储在这些叶子节点上；</p></li><li><p>叶子节点形成一个单项链表。</p><p><img src="D:\develop\typecho\themes\butterfly\source\img\1.png"></p></li></ol></li><li><p>B+tree特点：</p><p>MySQL索引数据结构对经典的B-tree进行了优化。在原B-tree的基础上，增加一个指向相邻叶子节点的链表指针，形成了双向链表，就形成了带有顺序指针的B+tree，提高了区间访问的性能。</p><p><img src="D:\develop\typecho\themes\butterfly\source\img\2.png"></p></li><li><p>Hash索引（Memory引擎）特点：</p><ol><li>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中，而如果存在hash冲突的键值（两个或者多个键值hash值相同），可以在对应槽位上增加链表来存储键值；</li><li>Hash索引只能用于对等比较（&#x3D;，in），不支持服务查询（between，&gt;,&lt;,…）;    </li><li>无法利用索引完成排序操作；  </li><li>查询效率高，通常情况只需要一次检索就可以了，效率通常要高于B+tree索引。</li></ol></li><li><p>为什么InnoDB存储引擎选择使用B+tree索引结构？</p><ol><li><p>相对于二叉树，B+tree的层级更加少，可以减少磁盘IO的次数，提高搜索效率；</p></li><li><p>相对于B-tree，因为在Mysql中一个节点代表一个分页，一个分页的大小是有限的（16kb），而B-tree中数据和索引存储在一个节点中，这样就会使得存储在一个节点上的key减少，造成树的高度增加，导致检索数据时磁盘IO次数增加，性能降低；</p></li><li><p>相对于Hash索引，B+tree支持的访问匹配和排序操作，叶子节点的双向链表结构便于范围搜索和排序。</p></li></ol></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><table><thead><tr><th align="left">分类</th><th align="left">含义</th><th align="left">特点</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">主键索引</td><td align="left">针对于表中主键创建的索引</td><td align="left">默认自动创建，且只能有一个</td><td align="left">primary</td></tr><tr><td align="left">唯一索引</td><td align="left">避免同一个表中某个数据列中存在相同数据</td><td align="left">可以有多个</td><td align="left">unique</td></tr><tr><td align="left">常规索引</td><td align="left">快速定位特定数据</td><td align="left">可以有多个</td><td align="left"></td></tr><tr><td align="left">全文索引</td><td align="left">全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td align="left">可以有多个</td><td align="left">fulltext</td></tr></tbody></table><p><strong>在InnDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</strong></p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（Clustered index）</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只能有一个</td></tr><tr><td>二级索引（Secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p><strong>聚集索引选取规则：</strong></p><ol><li>如果存在主键，主键索引就是聚集索引；</li><li>如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引；</li><li>如果表没有主键，或没有合适的唯一索引，则InnDB会自动生成一个rowid作为隐藏5的聚集索引。</li></ol><p><strong>简单点说</strong>聚集索引通过主键列上的值创建索引，把整行数据存储在索引所在叶子节点的下面，而二级索引就是通过索引列上的数据创建索引，而在叶子节点下存储的是该行数据的主键。</p><p><strong>InnoDB主键索引的B+tree高度为多高呢？？</strong></p><p>假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。则：</p><p>树高度为2：<br>n<em>8+(n+1)<em>6&#x3D;16</em>1024（一个节点指针比key多一个，一个节点大小为16k）n≈1170 1171</em>16&#x3D;18736<br> 树高度为3：                                                                                                                                           1171<em>1171</em>16&#x3D;21939856</p><h4 id="索引相关操作（SQL）"><a href="#索引相关操作（SQL）" class="headerlink" title="索引相关操作（SQL）"></a>索引相关操作（SQL）</h4><ol><li><p>查询索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure></li><li><p>创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] [fulltext] index 索引名字（自己取） <span class="keyword">on</span>  表名（要添加索引的字段名，可以是多个字段，多字段代表创建联合索引）；</span><br></pre></td></tr></table></figure></li><li><p>删除索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名。</span><br></pre></td></tr></table></figure></li></ol><h4 id="查询需要优化的SQL（运行慢的SQL）"><a href="#查询需要优化的SQL（运行慢的SQL）" class="headerlink" title="查询需要优化的SQL（运行慢的SQL）"></a>查询需要优化的SQL（运行慢的SQL）</h4><ul><li><p>查看当前数据库状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>慢查询日志：开启慢查询日志定位查询效率低的<code>sql</code>：</p><p>慢查询日志记录了所有执行时间超过指定参数（<code>long_query_time</code>,单位：秒，默认10秒）的所有<code>SQL</code>语句日志。<code>MySQL</code>的慢查询日志默认没有开启，需要在<code>MySQL</code>的配置文件（<code>/etc/my.cnf</code>）中做如下配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢日志查询</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被认定是慢查询，记录到查询日志</span><br><span class="line">log_query_time=2</span><br></pre></td></tr></table></figure><p>配置完成后，重启MySQL服务器测试，</p><p>查看慢日志文件中记录的信息<code>/var/lib/mysql/localhost-slow.log</code>。</p></li><li><p>profile详情查询sql执行时间：</p><p>查看数据库是否支持profile：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>开启profile查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>执行想判断的SQL，然后通过下面指令查询SQL的执行时间：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看每一条<span class="keyword">sql</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles；</span><br><span class="line"></span><br><span class="line">#查看指定query id 的<span class="keyword">sql</span>语句各阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">sql</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></li><li><p>explain执行计划:</p><p>语法：explain  + select 语句;</p><p>explain中各字段含义：</p><ol><li>id：select查询的序列号，表示查询中执行select子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。连表查询中一般两张表的id都相同且按from后表的顺序查询；如果有子查询子查询中的select的id会更大，子查询先执行。</li><li>select_type：表示select的类型，常见的取值有simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select&#x2F;where之后包含了子查询）等。</li><li>type：表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。<ul><li>NULL：业务代码中一般不太可能达到，不查询表的select查询：select ’A’；</li><li>system：一般出现在查询系统表时;</li><li>const：按主键索引查询;</li><li>ref：一般是二级索引查询;</li><li>range：范围匹配查询;</li><li>index：索引全表扫描;</li><li>all：全表扫描.</li></ul></li><li>possible_key：可能应用在这张表上的索引。</li><li>key：实际用到的索引.</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li>rows：MYSQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</li><li>filtered：表示返回结果的行数占读取行数的百分比，这个值越大越好。</li><li>Extra：其他信息。</li></ol><h4 id="索引使用相关规则"><a href="#索引使用相关规则" class="headerlink" title="索引使用相关规则"></a>索引使用相关规则</h4><ol><li><p><strong>最左前缀法则：</strong>使用联合索引查询时，必须遵守最左前缀法则；即where条件在必须包含复合索引中最左边第一个字段的条件，否则索引不生效，按照索引中字段的顺序，如果条件中不存在中间某个字段的条件，则后面字段的索引也不会生效。（注：where条件中只需要包含相关字段添加即可，条件顺序的并不影响索引的使用）联合查询中使用了范围查询（&gt;,&lt;）：范围查询右侧的列索引生效，在业务允许的条件下可以使用&lt;&#x3D;和&gt;&#x3D;索引就又可以使用了。</p></li><li><p><strong>不能在条件上加函数运算，否则索引将失效。</strong></p></li><li><p><strong>字符串不加引号，会引发隐式类型转换，导致索引失效。</strong></p></li><li><p><strong>模糊查询like：%加前面索引失效，%加后面索引还是生效的。%xx(失效)、xx%（生效）。</strong></p></li><li><p><strong>or连接条件：如果or两侧列都有索引则通过两侧索引查询，如果存在一侧没有索引则来一侧存在索引的列索引会失效。</strong></p></li><li><p><strong>数据评估影响（mysql实现）：如果查询的数据占了表中的大头，mysql判断使用全表扫描效率更高，mysql就会放弃使用索引，进行全表扫描。</strong></p></li><li><p><strong>SQL提示：是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</strong></p><ul><li><p>use index（索引名)   </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ignore index（索引名）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 忽略使用该索引，让这次查询不使用该索引。</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>force index（索引名） </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制此次查询使用该索引</span><br><span class="line"># 例如：</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index（idex_user_name） <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;zs&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>覆盖索引</strong>：</p></li></ol><ul><li><p>什么是回表查询？</p><p>场景：存在一张表user有3个字段主键id、name、age；列name存在二级索引，当我们使用select * from user where name &#x3D; ‘zs’,此时就存在回表查询。</p><p>解释：上述sql会根据name字段的二级索引进行查询，但是name字段上的二级索引只保存了name上的值和id，而我们使用select * 查询全字段信息，而age字段的信息是无法通过name字段的二级索引查询到的，这时候就需要进行回表查询，通过二级索引查询到的id再通过主键id的聚集索引查询到这条数据的所有信息。</p></li><li><p>覆盖索引避免回表查询：</p><p>可以使用联合索引，把经常需要查的字段信息合并到一个联合索引中，在select 后只添加这些需要查询的字段，即可通过二级索引就获得需要的字段信息，避免回表查询。</p></li></ul><ol start="9"><li><strong>前缀索引</strong>：</li></ol><ul><li><p>应用场景：大文本或者数据列建立索引时只截取文本前指定长度的数据当做索引。</p></li><li><p>索引长度指定规则：</p><p>当字段类型为字符串（varchar，text等）时,有时候需要索引很长的字符串，这样会让索引变得很大，因为节点的大小有限，单个索引变大，单个节点内可以存储的索引数量就会减少，树的高度就会增加，查询时，浪费大量的磁盘IO，影响查询效率。此时可以用字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure></li><li><p>前缀长度选择：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h4><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引过多，维护索引结构的代价就会过大，会影响增删改的效率。</li><li>如果索引列不能存储null值，请在创建表的时候使用not null约束它，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引最有利于查询。</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;a href=&quot;#MySQL的索引的相关知识总结：&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引的相关知识总结：&quot;&gt;&lt;/a&gt;&lt;strong&gt;MySQL的索引的相关知识总结：&lt;/strong&gt;&lt;/h3&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Development Tool</title>
    <link href="http://example.com/fwzssd/60588ca5.html"/>
    <id>http://example.com/fwzssd/60588ca5.html</id>
    <published>2022-08-26T07:21:03.000Z</published>
    <updated>2022-08-27T01:17:15.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发过程中相关工具的下载："><a href="#java开发过程中相关工具的下载：" class="headerlink" title="java开发过程中相关工具的下载："></a>java开发过程中相关工具的下载：</h2><h4 id="JDK的下载和环境配置："><a href="#JDK的下载和环境配置：" class="headerlink" title="JDK的下载和环境配置："></a>JDK的下载和环境配置：</h4><ul><li><p><input disabled="" type="checkbox"> jdk的下载（建议下载1.8和11的版本）：</p><ol><li><p>打开浏览器输入网址 <a href="https://www.oracle.com/index.html%EF%BC%8C%E8%BF%9B%E5%85%A5[Oracle%E5%AE%98%E7%BD%91](https://www.oracle.com/index.html)">https://www.oracle.com/index.html，进入[Oracle官网](https://www.oracle.com/index.html)</a> ，在<code>Producet</code>下找到<code>Java</code>根据自己的操作系统选择对应的版本进行下载；</p></li><li><p>jdk安装：</p><p> 2.1 下载完JDK到本地后，找到该文件，双击运行JDK安装程序 ，进入JDK安装界面，点击下一步； </p><p>2.2 可以直接默认目录，点击下一步。也可以自定义路径，先创建一个文件夹名为Java，再在该文件夹下创建一个文件夹为JDK安装目录，同时创建一个文件夹为JRE安装目录 ；</p><p> 2.3然后回到JDK安装界面，更改安装路径，为上述所创建的JDK路径，点击下一步（<strong>这里由于第一项开发工具中已经自带了 JRE，则第三项的公共 JRE 可以取消独立安装，上述创建的 JRE 文件夹也不需要了</strong>）。无其他需求，取消安装JRE即可；</p><p>2.4等待一会，会进入 JRE 的安装界面，同样的更改路径，为上述所创建的 JRE 路径，更改完之后点击下一步（<strong>在上一步取消公共 JRE 安装的则不会出现下面的界面，直接到 2.5 安装完成</strong>）； </p><p>2.5至此JDK已经安装完毕，点击关闭 ；</p><p>2.6测试是否安装成功：可以进入安装好的jdk中的bin目录下打开cmd窗口运行<code>java -version</code>出现信息即可。</p></li><li><p>windows版本的jdk百度网盘下载：链接: <a href="https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8">https://pan.baidu.com/s/1H4hOG2oSb-zkgy23y53gCg?pwd=k8d8</a> 提取码: k8d8 复制这段内容后打开百度网盘手机App，操作更方便哦</p></li></ol></li><li><p><input disabled="" type="checkbox"> jdk运行环境的配置（为了在任何终端都可以使用jdk）：</p><p>1.windows操作系统中找到系统的高级设置；</p></li></ul><p>​       2.找到环境变量</p><p>​       3.点击新增；</p><p>​       4.新增变量<code>JAVA_HOME</code>，变量值是安装的jdk的根目录（包含bin目录的那个目录）；</p><p>​       5.找到变量<code>Path</code>新增变量 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code> ；</p><p>​       6.测试，在任意终端输入<code>javac</code>得到java配置信息即表示配置成功。</p><h4 id="idea下载和破解："><a href="#idea下载和破解：" class="headerlink" title="idea下载和破解："></a>idea下载和破解：</h4><ul><li><p><input disabled="" type="checkbox"> idea的安装包的下载（建议不要下载过新的版本，使用20~21版本即可方便破解）：</p><ol><li><p>打开浏览器输入<a href="https://www.jetbrains.com/%EF%BC%8C%E8%BF%9B%E5%85%A5">https://www.jetbrains.com/，进入</a> <a href="https://www.jetbrains.com/">Jetbrains官网</a>，点击 Developer Tools，再点击 Intellij IDEA ；</p></li><li><p>点击中间的download，进入IDEA下载界面 ；</p></li><li><p>选择左边的Ultimate版本进行下载安装。Ultimate版本为旗舰版，需要付费，包括完整的功能。Community 版本为社区版，免费，只支持部分功能。这里我们选择左边 Ultimate 版本进行下载，后续进行激活 ；</p></li></ol></li><li><p><input disabled="" type="checkbox"> ​     idea安装：</p><ol><li><p>下载完后在本地找到该文件，双击运行 idea 安装程序 ；</p></li><li><p>点击 Next ；</p></li><li><p>选择安装路径，Next ；</p></li></ol></li></ul><p>​          4.按需求选择，点击 Next ,版本不同有不同的选择，之前版本可能需要选择电脑的版本；</p><p>​          5.默认，不用改，直接点 Install，安装 ；</p><p>​         6.安装完成后，点击 Finish，也可勾选Run Intellij IDEA 再点击 Finish，会自动打开安装好的 IDEA 。</p><ul><li><p><input disabled="" type="checkbox"> 破解idea：</p><p>破解idea主要有两种破解方式，永久版破解到2099年，参考 <a href="http://www.itmind.net/13082.html">IntelliJ IDEA 2021.3.3破解教程（亲测有效，激活至2099年） (itmind.net)</a> ；刷新试用时间版，参考 <a href="http://www.itmind.net/12400.html">2022年IntelliJ IDEA最新破解教程，无限重置试用期 (亲测有效) (图文教程) (itmind.net)</a> ；刷新试用时间的破解方式比较容易操作。</p><p>（内附2021版本idea下载破解商品链接: <a href="https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA">https://pan.baidu.com/s/1vdcG-rB9xmRytpr0r-08jA</a> 提取码: 865s 复制这段内容后打开百度网盘手机App，操作更方便哦）</p></li></ul><h4 id="maven的下载和配置："><a href="#maven的下载和配置：" class="headerlink" title="maven的下载和配置："></a>maven的下载和配置：</h4><p>1.官网 <a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a> 下载压缩包；</p><p>2.放到安装目录直接解压即可；</p><p>3.国内访问中央仓库过慢，在config包的setting.xml中配置阿里云的镜像地址，加速依赖下载；</p><p>在<mirrors>标签中配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.环境配置：和jdk一样，在系统的环境变量中配置maven的变量；</p><p>变量名：MAVEN_HOME</p><p>变量值：maven的根目录</p><p>5.在<code>path</code>变量中新增<code>%MAVEN_HOME%\bin</code>变量</p><h4 id="git的下载："><a href="#git的下载：" class="headerlink" title="git的下载："></a>git的下载：</h4><p>1.进入官网 <a href="https://git-scm.com/">吉特 (git-scm.com)</a> 下载安装包；</p><p>2.双击安装包安装，一直点击next,直到出现install,点击install,然后点击finish，安装完成。 </p><p>3.安装完成后，桌面右键出现Git GUI、Git bash选项，说明已安装： </p><h4 id="数据库图形化软件："><a href="#数据库图形化软件：" class="headerlink" title="数据库图形化软件："></a>数据库图形化软件：</h4><p>1.下载破解Navicat： <a href="http://www.itmind.net/13042.html">Navicat Premium 15 破解激活教程,永久有效(亲测可用) (itmind.net)</a> </p><p>或者 <a href="https://www.downkuai.com/soft/150597.html">Navicat 16破解版(附激活秘钥)下载-Navicat premium 16破解版下载 v16.0.4附安装破解教程-当快软件园 (downkuai.com)</a> </p><h4 id="Redis图形化软件："><a href="#Redis图形化软件：" class="headerlink" title="Redis图形化软件："></a>Redis图形化软件：</h4><p>1.RedisDesktopManager安装包链接: <a href="https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law">https://pan.baidu.com/s/172tO9PwLGmCkAdZ6UT_Law</a> 提取码: 8s8d 复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>2.QuickRedis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;a href=&quot;#java开发过程中相关工具的下载：&quot; class=&quot;headerlink&quot; title=&quot;java开发过程中相关工具的下载：&quot;&gt;&lt;/a&gt;java开发过程中相关工具的下载：&lt;/h2&gt;&lt;h4 id=&quot;JDK的下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/fwzssd/4a17b156.html"/>
    <id>http://example.com/fwzssd/4a17b156.html</id>
    <published>2022-08-25T09:37:53.819Z</published>
    <updated>2022-08-27T01:25:42.638Z</updated>
    
    <content type="html"><![CDATA[<p>快速发布新文章</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="发布到线上"><a href="#发布到线上" class="headerlink" title="发布到线上"></a>发布到线上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快速发布新文章&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;h3 id=&quot;新增文章&quot;&gt;&lt;a href=&quot;#新增文章&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
  </entry>
  
</feed>
